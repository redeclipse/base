////////////////////////////////////////////////
//
// model shaders
//
////////////////////////////////////////////////

// skeletal animation with dual quaternions

qtangentdecode = [
    ? $arg1 [
        vec4 qxyz = mquat.xxyy*mquat.yzyz, qxzw = vec4(mquat.xzw, -mquat.w);
        vec3 mtangent = (qxzw.yzw*mquat.zzy + qxyz.zxy)*vec3(-2.0, 2.0, 2.0) + vec3(1.0, 0.0, 0.0);
        vec3 mnormal = (qxzw.zwx*mquat.yxx + qxyz.ywz)*vec3(2.0, 2.0, -2.0) + vec3(0.0, 0.0, 1.0);
        // vec3 mtangent = cross(mquat.xyz, vec3(mquat.wz, -mquat.y))*2.0 + vec3(1.0, 0.0, 0.0);
        // vec3 mnormal = cross(mquat.xyz, vec3(mquat.y, -mquat.x, mquat.w))*2.0 + vec3(0.0, 0.0, 1.0);
    ] [
        vec3 mnormal = cross(mquat.xyz, vec3(mquat.y, -mquat.x, mquat.w))*2.0 + vec3(0.0, 0.0, 1.0);
    ]
]

skelanimdefs = [
    result [
        attribute vec4 vboneweight, vboneindex; 
        //:uniform animdata
        uniform vec4 animdata[@@(min $maxvsuniforms $maxskelanimdata)];
    ]
]

skelanim = [
    result [
        int index = int(vboneindex.x);
        @(if (= $arg1 1) [result [
            vec4 dqreal = animdata[index];
            vec4 dqdual = animdata[index+1];
        ]] [result [
            vec4 dqreal = animdata[index] * vboneweight.x;
            vec4 dqdual = animdata[index+1] * vboneweight.x;
            index = int(vboneindex.y);
            dqreal += animdata[index] * vboneweight.y;
            dqdual += animdata[index+1] * vboneweight.y;
            @(if (>= $arg1 3) [result [
                index = int(vboneindex.z);
                dqreal += animdata[index] * vboneweight.z;
                dqdual += animdata[index+1] * vboneweight.z;
            ]])
            @(if (>= $arg1 4) [result [
                index = int(vboneindex.w);
                dqreal += animdata[index] * vboneweight.w;
                dqdual += animdata[index+1] * vboneweight.w;
            ]])
            float len = length(dqreal);
            dqreal /= len;
            dqdual /= len;
        ]])

        vec4 mpos = vec4((cross(dqreal.xyz, cross(dqreal.xyz, vvertex.xyz) + vvertex.xyz*dqreal.w + dqdual.xyz) + dqdual.xyz*dqreal.w - dqreal.xyz*dqdual.w)*2.0 + vvertex.xyz, vvertex.w);

        @(if (>= $numargs 2) [result [
            vec4 mquat = vec4(cross(dqreal.xyz, vtangent.xyz) + dqreal.xyz*vtangent.w + vtangent.xyz*dqreal.w, dqreal.w*vtangent.w - dot(dqreal.xyz, vtangent.xyz));
            @(qtangentdecode $arg2)
        ]])
    ]
]

windanimdefs = [
    result [
#define WIND_SWAY_SCALE 2
#define WIND_DETAIL1_ZSWAY 1
#define WIND_DETAIL2_ZSWAY 0.75
#define WIND_DETAIL1_SWAY_SCALE 2
#define WIND_DETAIL2_SWAY_SCALE 1.5
#define WIND_DETAIL1_SWAY_FREQ 2.0
#define WIND_DETAIL2_SWAY_FREQ 9.0
#define WIND_PHASE_SHIFT_SCALE 123.0

        attribute vec4 vcolor;
        uniform float millis;
        uniform mat4 @arg1;
        uniform vec3 windparams;
        uniform vec3 windvec;

        float curve(float x) { return x * x * (3.0 - 2.0 * x); }
        float triangle(float x) { return abs(fract(x + 0.5) * 2.0 - 1.0); }
        float curvefunc(float x) { return curve(triangle(x)) * 2.0 - 1.0; }

        vec3 windsway(vec3 wind, vec3 crosswind, float phase, float factor1, float factor2, float zsway)
        {
            float basesway = curvefunc(phase);
            vec3 result = vec3(0, 0, 0);

            result += (vec3(basesway, basesway, basesway) * wind * factor1) + (wind * 10);
            result += vec3(basesway, curvefunc(phase + 0.25), curvefunc(phase + 0.75)) * (
                (crosswind + vec3(0, 0, zsway)) * factor1 * 2);

            return result * factor2;
        }
    ]
]

windanim = [
    result [
        if (windparams.x > 0.0)
        {
            float theta = (millis + windparams.y) * 0.4f;
            float detailphase1 = vcolor.g * WIND_PHASE_SHIFT_SCALE;
            float detailphase2 = dot(mpos.xyz, vec3(detailphase1)) + 0.1 +
                (vcolor.g * WIND_PHASE_SHIFT_SCALE);

            float force = length(windvec);
            vec3 windhorizontal = vec3(windvec.x, windvec.y, 0);
            vec3 crosswind = cross(windhorizontal, vec3(0, 0, 1));

            vec3 wind = vec3(0, 0, 0);

            wind += windsway(windvec, crosswind, theta, WIND_SWAY_SCALE, mpos.z * 0.01, 0);
            wind += windsway(windvec, crosswind, theta * WIND_DETAIL1_SWAY_FREQ + detailphase1,
                1, vcolor.b * WIND_DETAIL1_SWAY_SCALE, WIND_DETAIL1_ZSWAY * force);
            wind += windsway(windvec, crosswind, theta * WIND_DETAIL2_SWAY_FREQ + detailphase2,
                1, vcolor.r * WIND_DETAIL2_SWAY_SCALE, WIND_DETAIL2_ZSWAY * force);

            gl_Position += @arg1 * vec4(wind, 0.0);
        }
    ]
]

// mdltype:
//    a -> alpha test
//    b -> dual-quat skeletal animation
//    w -> wind

mdlopt = [ >= (strstr $modeltype $arg1) 0 ]

shadowmodelvertexshader = [
    local modeltype
    modeltype = $arg1
    result [
        attribute vec4 vvertex;
        @(if (mdlopt "b") [skelanimdefs $arg2])
        uniform mat4 modelmatrix;
        @(? (mdlopt "a") [
            attribute vec2 vtexcoord0;
            uniform vec2 texscroll;
            varying vec2 texcoord0;
        ])
        @(if (mdlopt "w") [windanimdefs "shadowmatrix"])
        void main(void)
        {
            @(if (mdlopt "b") [
                skelanim $arg2
            ] [result [
                #define mpos vvertex
            ]])

            gl_Position = modelmatrix * mpos;

            @(if (mdlopt "w") [windanim "shadowmatrix"])

            @(? (mdlopt "a") [
                texcoord0 = vtexcoord0 + texscroll;
            ])
        }
    ]
]

shadowmodelfragmentshader = [
    local modeltype
    modeltype = $arg1
    result [
        @(? (mdlopt "a") [
            uniform sampler2D tex0;
            uniform float alphatest;
            varying vec2 texcoord0;
        ])
        void main(void)
        {
            @(? (mdlopt "a") [
                vec4 color = texture2D(tex0, texcoord0);
                if(color.a <= alphatest)    
                    discard;
            ])
        }
    ]
]

shadowmodelshader = [
    defershader 0 $arg1 [
        shader 0 @arg1 (shadowmodelvertexshader @arg2) (shadowmodelfragmentshader @arg2)
        loop+ i 1 4 [
            variantshader 0 @@arg1 0 (shadowmodelvertexshader @@(concatword $arg2 "b") $i) []
        ]
    ]
]

shadowmodelshader "shadowmodel" ""
shadowmodelshader "alphashadowmodel" "a"
shadowmodelshader "windshadowmodel" "aw"

// mdltype:
//    a -> alpha test
//    e -> envmap
//    n -> normalmap
//    m -> masks
//    d -> decal
//    D -> alpha decal
//    b -> dual-quat skeletal animation
//    c -> disable cullface
//    t -> transparent 
//    x -> game specified mixer
//    p -> game specified pattern
//    w -> wind

modelvertexshader = [
    local modeltype
    modeltype = $arg1
    result [
        attribute vec4 vvertex, vtangent;
        attribute vec2 vtexcoord0;
        @(if (mdlopt "b") [skelanimdefs $arg2 (mdlopt "n")])
        uniform mat4 modelmatrix;
        uniform mat3 modelworld;
        uniform vec3 modelcamera;
        uniform vec2 texscroll;
        @(? (mdlopt "n") [
            varying mat3 world;
        ] [
            varying vec3 nvec;
        ])
        @(? (mdlopt "e") [
            varying vec3 camvec;
        ])
        @(msaainterpvert)
        varying vec2 texcoord0;
        @(? (mdlopt "p") [
            uniform float patternscale;
            varying vec2 texcoord1;
        ])
        @(if (mdlopt "w") [windanimdefs "camprojmatrix"])

        void main(void)
        {
            @(if (mdlopt "b") [
                skelanim $arg2 (mdlopt "n")
            ] [result [
                #define mpos vvertex
                #define mquat vtangent
                @(qtangentdecode (mdlopt "n"))
            ]])

            gl_Position = modelmatrix * mpos;

            @(if (mdlopt "w") [windanim "camprojmatrix"])

            texcoord0 = vtexcoord0 + texscroll;

            @(? (mdlopt "p") [
                texcoord1 = texcoord0 * patternscale;
            ])

            @(msaapackvert)

            @(? (mdlopt "e") [
                camvec = modelworld * normalize(modelcamera - mpos.xyz);
            ])

            @(? (mdlopt "n") [
                // composition of tangent -> object and object -> world transforms
                //   becomes tangent -> world
                vec3 wnormal = modelworld * mnormal;
                vec3 wtangent = modelworld * mtangent;
                vec3 wbitangent = cross(wnormal, wtangent) * (vtangent.w < 0.0 ? -1.0 : 1.0);
                world = mat3(wtangent, wbitangent, wnormal);
            ] [
                nvec = modelworld * mnormal;
            ])
        }
    ]
]

modelfragmentshader = [
    local modeltype
    modeltype = $arg1
    result [
        @(? (mdlopt "n") [
            varying mat3 world; 
        ] [
            varying vec3 nvec;
        ])
        @(? (mdlopt "e") [
            uniform vec2 envmapscale;
            varying vec3 camvec;
        ])
        uniform vec4 colorscale;
        uniform vec3 material1, material2;
        uniform vec2 matbright, fullbright;
        uniform vec3 maskscale;
        @(? (mdlopt "a") [uniform float alphatest;])
        uniform sampler2D tex0;
        @(? (mdlopt "m") [uniform sampler2D tex1;])
        @(? (mdlopt "e") [uniform samplerCube tex2;])
        @(? (mdlopt "n") [uniform sampler2D tex3;])
        @(? (|| (mdlopt "d") [mdlopt "D"]) [uniform sampler2D tex4;])
        @(? (mdlopt "x") [
            uniform vec4 mixercolor;
            uniform vec2 mixerglow, mixerscroll;
            uniform sampler2D tex5;
        ])
        @(? (mdlopt "p") [
            varying vec2 texcoord1;
            uniform sampler2D tex6;
        ])
        @(msaainterpfrag)
        varying vec2 texcoord0;
        uniform float aamask;

        void main(void)
        {
            vec4 diffuse = texture2D(tex0, texcoord0);

            @(? (mdlopt "a") [
                if(diffuse.a <= alphatest)
                    discard;
            ])

            gcolor.rgb = diffuse.rgb*colorscale.rgb;

            @(if (mdlopt "n") [result [
                vec3 normal = texture2D(tex3, texcoord0).rgb - 0.5;
                @(? (mdlopt "c") [
                    if(!gl_FrontFacing) normal.z = -normal.z;
                ])
                normal = normalize(world * normal);
            ]] [result [
                vec3 normal = normalize(nvec);
                @(? (mdlopt "c") [
                    if(!gl_FrontFacing) normal = -normal;
                ])
            ]])

            float spec = maskscale.x;
            @(if (mdlopt "m") [result [
                vec4 masks = texture2D(tex1, texcoord0);
                float glowk = max(maskscale.z*masks.g, fullbright.y); // glow mask in green channel
                spec *= masks.r; // specmap in red channel
                @(? (mdlopt "p") [float delta = max(masks.g, 1.0-texture2D(tex6, texcoord1).r);] [float delta = max(masks.g, masks.a);])
                gcolor.rgb *= mix(material2*matbright.y, material1*matbright.x, delta);
                @(? (mdlopt "e") [
                    vec3 camn = normalize(camvec);
                    float invfresnel = dot(camn, normal);
                    vec3 rvec = 2.0*invfresnel*normal - camn;
                    float rmod = envmapscale.x*clamp(invfresnel, 0.0, 1.0) + envmapscale.y;
                    vec3 reflect = textureCube(tex2, rvec).rgb;
                    gcolor.rgb = mix(gcolor.rgb, reflect, rmod*masks.b); // envmap mask in blue channel
                ])
            ]] [result [
                float glowk = fullbright.y;
                @(? (mdlopt "p") [
                    gcolor.rgb *= mix(material2*matbright.y, material1*matbright.x, texture2D(tex6, texcoord1).r);
                ] [
                    gcolor.rgb *= material1*matbright.x;
                ])
            ]])
            @(gspecpack maskscale.y spec)

            @(? (|| (mdlopt "d") [mdlopt "D"]) [
                vec4 decal = texture2D(tex4, texcoord0);
                @(? (mdlopt "D") [
                    gcolor.rgb = mix(gcolor.rgb, decal.rgb, decal.a);
                ] [
                    gcolor.rgb += decal.rgb;
                ])
            ])

            @(? (mdlopt "x") [
                vec4 mixer = texture2D(tex5, texcoord0 + vec2(0, mixerscroll.y)), mixer2 = texture2D(tex5, texcoord0 + vec2(mixerscroll.x, 0.0));
                mixer.rgb += mixer2.rgb;
                mixer.a = max(mixer.a, mixer2.a);
                gcolor.rgb = mix(gcolor.rgb, mixer.rgb*mixercolor.rgb, mixer.a*mixercolor.a);
                glowk += mix(0.0, ((mixer.r+mixer.g+mixer.b)/3.0)*mixerglow.x, mixer.a*mixerglow.y);
            ])

            float colork = clamp(fullbright.x - glowk, 0.0, 1.0);

            @(if (mdlopt "t") [result [
                gcolor *= colorscale.a;
                gglow.rgb = gcolor.rgb*glowk;
                gcolor.rgb *= colork;
                #define packnorm colorscale.a
            ]] [gglowpack "" packnorm])

            @(gnormpackdef normal packnorm)

            @(msaapackfrag aamask)
        }
    ]
]

modelshader = [
    shadername = (concatword "model" $arg1)
    maxvariants = 9
    shader 0 $shadername (modelvertexshader $arg1) (modelfragmentshader $arg1)
    loop+ i 1 4 [
        variantshader 0 $shadername 0 (modelvertexshader (concatword $arg1 "b") $i) [] $maxvariants
    ]
    variantshader 0 $shadername 1 [] (modelfragmentshader (concatword $arg1 "t")) $maxvariants
    loop i 4 [
        variantshader 0 $shadername 1 [0 , @i] 1 $maxvariants
    ]
]

rsmmodelvertexshader = [
    local modeltype
    modeltype = $arg1
    result [
        attribute vec4 vvertex, vtangent;
        attribute vec2 vtexcoord0;
        @(if (mdlopt "b") [skelanimdefs $arg2 (mdlopt "n")])
        uniform mat4 modelmatrix;
        uniform mat3 modelworld;
        uniform vec2 texscroll;
        varying vec2 texcoord0;
        varying vec3 nvec;
        void main(void)
        {
            @(if (mdlopt "b") [
                skelanim $arg2 (mdlopt "n")
            ] [result [
                #define mpos vvertex
                #define mquat vtangent
                @(qtangentdecode (mdlopt "n"))
            ]])

            gl_Position = modelmatrix * mpos;

            texcoord0 = vtexcoord0 + texscroll;

            nvec = modelworld * mnormal;
        }
    ]
]

rsmmodelfragmentshader = [
    local modeltype
    modeltype = $arg1
    result [
        varying vec2 texcoord0;
        varying vec3 nvec;
        uniform vec4 colorscale;
        @(? (mdlopt "a") [uniform float alphatest;])
        uniform vec3 rsmdir;
        uniform sampler2D tex0;
        fragdata(0) vec4 gcolor;
        fragdata(1) vec4 gnormal;
        void main(void)
        {
            vec4 diffuse = texture2D(tex0, texcoord0);
            @(? (mdlopt "a") [
                if(diffuse.a <= alphatest)
                    discard;
            ])
            vec3 normal = normalize(nvec);
            @(? (mdlopt "c") [
                if(!gl_FrontFacing) normal = -normal;
            ])
            gcolor = vec4(dot(normal, rsmdir)*diffuse.rgb*colorscale.rgb, 1.0);
            gnormal = vec4(normal*0.5+0.5, 0.0);
        }
    ]
]

rsmmodelshader = [
    shadername = (concatword "rsmmodel" $arg1)
    shader 0 $shadername (rsmmodelvertexshader $arg1) (rsmmodelfragmentshader $arg1)
    loop+ i 1 4 [
        variantshader 0 $shadername 0 (rsmmodelvertexshader (concatword $arg1 "b") $i) []
    ]
]

