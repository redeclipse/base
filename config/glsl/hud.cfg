///////////////////////////////////////////////////
//
// used for rendering to the HUD
//
///////////////////////////////////////////////////

shader 0 "hud" [
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 hudmatrix;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        texcoord0 = vtexcoord0; 
        colorscale = vcolor;
    }
] [
    uniform sampler2D tex0;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    fragdata(0) vec4 fragcolor;
    void main(void)
    {
        vec4 color = texture2D(tex0, texcoord0);
        fragcolor = colorscale * color;
    }
]

shader 0 "hudtext" [
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 hudmatrix;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        texcoord0 = vtexcoord0; 
        colorscale = vcolor;
    }
] [
    uniform sampler2D tex0;
    uniform vec4 textparams;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    fragdata(0) vec4 fragcolor;
    void main(void)
    {
        vec4 color = texture2D(tex0, texcoord0);
        fragcolor = colorscale * color;
    }
]

shader 0 "hudrgb" [
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 hudmatrix;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        texcoord0 = vtexcoord0; 
        colorscale = vcolor;
    }
] [
    uniform sampler2D tex0;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    fragdata(0) vec4 fragcolor;
    void main(void)
    {
        vec4 color = texture2D(tex0, texcoord0);
        fragcolor.rgb = colorscale.rgb * color.rgb;
        fragcolor.a   = colorscale.a;
    }
]

shader 0 "hudnotexture" [
    attribute vec4 vvertex, vcolor;
    uniform mat4 hudmatrix;
    varying vec4 color;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        color = vcolor;
    }
] [
    varying vec4 color;
    fragdata(0) vec4 fragcolor;
    void main(void)
    {
        fragcolor = color;
    }
]

shader 0 "hudrect" [
    attribute vec4 vvertex, vcolor;
    attribute vec2 vtexcoord0;
    uniform mat4 hudmatrix;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        texcoord0 = vtexcoord0; 
        colorscale = vcolor;
    }
] [
    uniform sampler2DRect tex0;
    varying vec2 texcoord0;
    varying vec4 colorscale;
    fragdata(0) vec4 fragcolor;
    void main(void)
    {
        fragcolor = colorscale * texture2DRect(tex0, texcoord0);
    }
]

shader 0 "hud3d" [
    attribute vec4 vvertex, vcolor;
    attribute vec3 vtexcoord0;
    uniform mat4 hudmatrix;
    varying vec3 texcoord0;
    varying vec4 color;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        texcoord0 = vtexcoord0;
        color = vcolor;
    }
] [
    uniform sampler3D tex0;
    varying vec3 texcoord0;
    varying vec4 color;
    fragdata(0) vec4 fragcolor;
    void main(void)
    {
        fragcolor = color * texture3D(tex0, texcoord0);
    }
]

shader 0 "hudcubemap" [
    attribute vec4 vvertex, vcolor;
    attribute vec3 vtexcoord0;
    uniform mat4 hudmatrix;
    varying vec3 texcoord0;
    varying vec4 colorscale;
    void main(void)
    {
        gl_Position = hudmatrix * vvertex;
        texcoord0 = vtexcoord0;
        colorscale = vcolor;
    }
] [
    uniform samplerCube tex0;
    varying vec3 texcoord0;
    varying vec4 colorscale;
    fragdata(0) vec4 fragcolor;
    void main(void)
    {
        fragcolor = colorscale * textureCube(tex0, texcoord0);
    }
]

// uses [(-1, -1), (1, 1)] coordinates
shader 0 "hudbackground" [
    uniform mat4 hudmatrix;
    attribute vec4 vvertex;
    varying vec2 pos;
    void main() {
        gl_Position = hudmatrix * vvertex;
        pos = vec2(vvertex.x, vvertex.y);
    }
] [
    const vec3 foreground = vec3(1.0, 0.0, 0.0);
    const vec2 center = vec2(0.0, 1.5);
    const float maxdist = distance(center, vec2(-1, -1));
    const float waterweight = 1.2;
    const float caustweight = 0.9;
    const float cloudweight = 0.5;
    const float timescale = 1.0 / 200.0;

    const float totalweight = caustweight + waterweight + cloudweight;
    const float caustw = caustweight / totalweight;
    const float waterw = waterweight / totalweight;
    const float cloudw = cloudweight / totalweight;

    uniform float time;
    uniform sampler2D tex0; // water
    uniform sampler2D tex1; // caustic
    uniform sampler2D tex2; // cloud

    varying vec2 pos;

    fragdata(0) vec4 fragcolor;

    void main() {
        vec2 dir = pos - center;
        float dist = length(dir);
        dir = dir / dist;
        float angle = (dot(dir, vec2(1.0, 0.0)) + 1.0) / 2.0;

        // rays
        vec2 uv = vec2(angle, time * timescale);
        float ray = waterw * -log(-log(texture2D(tex0, uv / 3.0).r)) + caustw * texture2D(tex1, uv).r;
        ray = clamp(ray, 0.0, 1.0);
        vec3 fg = foreground * ray;

        // bg
        vec2 cuv = (pos + 1.0) / 2.0;
        float cloud = cloudw * texture2D(tex2, cuv).r;
        vec3 bg = foreground * cloud;

        float k = log(dist) / log(maxdist);
        fragcolor = vec4(mix(fg, bg, k), 1);
    }
]
