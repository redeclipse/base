////////////////////////////////////////////////////////
//
// world shaders
//
///////////////////////////////////////////////////////

// worldtype:
//    e -> reserve envmap texture slot
//    r -> envmap reflection
//    R -> modulate envmap reflection with spec map
//    s -> spec
//    S -> spec map
//    g -> glow
//    G -> pulse glow
//    b -> blendmap
//    a -> transparent
//    A -> refractive
//    m -> alpha-mask
//    T -> triplanar
//    d -> detail
//    v -> displacement

wtopt = [ >= (strstr $worldtype $arg1) 0 ]

worldvariantshader = [
    local worldtype
    worldtype = $arg2
    stype = $SHADER_WORLD
    if (wtopt "e") [
        stype = (| $stype $SHADER_ENVMAP)
    ]
    srow = -1
    if (wtopt "G") [
        stype = (| $stype $SHADER_DYNAMIC)
        defuniformparam "glowcolor" 1 1 1 // glow color
        defuniformparam "pulseglowspeed" 1     // pulse frequency (Hz)
        defuniformparam "pulseglowcolor" 0 0 0 // pulse glow color
        defuniformparam "pulseglowoffset" 0 // pulse glow offset
    ] [if (wtopt "g") [
        defuniformparam "glowcolor" 1 1 1  // glow color
    ]]
    if (wtopt "R") [
        defuniformparam "envmin" 0 0 0 // minimum reflectivity
        defuniformparam "envscale" 1 1 1 // reflectivity map multiplier
    ] [if (wtopt "r") [
        defuniformparam "envmin" 0 0 0 // minimum reflectivity
        defuniformparam "envscale" 0.2 0.2 0.2 // reflectivity
    ]]
    defuniformparam "gloss" 1 // glossiness
    if (wtopt "S") [
        defuniformparam "specscale" 2 2 2 // spec map multiplier
    ] [if (wtopt "s") [
        defuniformparam "specscale" 1 1 1 // spec multiplier
    ]]
    if (wtopt "T") [
        defuniformparam "triplanarbias" 0.3 0.3 0.3
        stype = (| $stype $SHADER_TRIPLANAR)
    ]
    if (wtopt "b") [
        srow = 0
    ]
    if (wtopt "a") [
        if (wtopt "A") [stype = (| $stype $SHADER_REFRACT)]
        srow = 1
    ]
    if (wtopt "v") [
        defuniformparam "dispscale" 0.125 0.125 0.125 0.125 // displacement scale modifier
        defuniformparam "dispscroll" 0.0 0.125 0.25 -0.25 // displacement scroll modifier
        defuniformparam "dispcontrib" 1.0 1.0 0.125 // displacement texture contribution
    ]
    variantshader $stype $arg1 $srow [
        attribute vec4 vvertex;
        attribute vec3 vnormal;
        attribute vec2 vtexcoord0;
        uniform mat4 camprojmatrix;
        uniform vec2 texgenscroll;
        uniform vec3 rotate;
        varying vec3 nvec;
        @(ginterpvert (|| $msaalight [&& $msaasamples [! (wtopt "a")]]))
        @(if (wtopt "T") [result [
            uniform vec2 texgenscale;
            varying vec2 texcoordx, texcoordy, texcoordz;
            @(? (wtopt "v") [
                varying vec2 dispcoordx0, dispcoordy0, dispcoordz0, dispcoordx1, dispcoordy1, dispcoordz1;
            ])
            @(? (wtopt "d") [uniform vec2 detailscale;])
        ]] [result [
            varying vec2 texcoord0;
            @(? (wtopt "v") [varying vec2 dispcoord0, dispcoord1;])
        ]])
        @(? (wtopt "r") [uniform vec3 camera; varying vec3 camvec;])
        @(? (wtopt "G") [flat varying float pulse;])
        @(? (wtopt "b") [
            uniform vec4 blendmapparams;
            varying vec2 texcoord1;
        ])
        @(? (|| (wtopt "G") (wtopt "v")) [uniform float millis;])

        void main(void)
        {
            gl_Position = camprojmatrix * vvertex;
            @(if (wtopt "T") [result [
                texcoordx = vec2(vvertex.y, -vvertex.z) * texgenscale;
                texcoordy = vec2(vvertex.x, -vvertex.z) * texgenscale;
                texcoordz = vvertex.xy * @(? (wtopt "d") "detailscale" "texgenscale");
                @(? (wtopt "v") [
                    dispcoordx0 = (texcoordx + millis*dispscroll.xy) * dispscale.xy;
                    dispcoordy0 = (texcoordy + millis*dispscroll.xy) * dispscale.xy;
                    dispcoordz0 = (texcoordz + millis*dispscroll.xy) * dispscale.xy;
                    dispcoordx1 = (texcoordx + millis*dispscroll.zw) * dispscale.zw;
                    dispcoordy1 = (texcoordy + millis*dispscroll.zw) * dispscale.zw;
                    dispcoordz1 = (texcoordz + millis*dispscroll.zw) * dispscale.zw;
                ])
            ]] [result [
                texcoord0 = vtexcoord0 + texgenscroll;
                @(rottexcoord texcoord0 rotate)
                @(? (wtopt "v") [
                    dispcoord0 = (texcoord0 + millis*dispscroll.xy) * dispscale.xy;
                    dispcoord1 = (texcoord0 + millis*dispscroll.zw) * dispscale.zw;
                ])
            ]])
            @(? (wtopt "b") [
                texcoord1 = (vvertex.xy - blendmapparams.xy)*blendmapparams.zw;
            ])
            nvec = vnormal;

            @(gdepthpackvert (|| $msaalight [&& $msaasamples [! (wtopt "a")]]))

            @(? (wtopt "r") [camvec = camera - vvertex.xyz;])

            @(? (wtopt "G") [
                pulse = abs(fract((millis+pulseglowoffset.x)*pulseglowspeed.x)*2.0 - 1.0);
            ])
        }
    ] [
        @(if (wtopt "A") [result [
            @(gfetchdefs refractlight)
            uniform vec4 refractparams;
        ]])
        uniform vec4 colorparams;
        uniform sampler2D diffusemap;
        @(? (|| $msaalight [&& $msaasamples [! (wtopt "a")]]) [uniform float hashid;])
        varying vec3 nvec;
        @(ginterpfrag (|| $msaalight [&& $msaasamples [! (wtopt "a")]]))
        @(if (wtopt "T") [result [
            varying vec2 texcoordx, texcoordy, texcoordz;
            @(? (wtopt "v") [varying vec2 dispcoordx0, dispcoordy0, dispcoordz0, dispcoordx1, dispcoordy1, dispcoordz1;])
            @(? (wtopt "d") [uniform sampler2D diffusedetail;])
        ]] [result [
            varying vec2 texcoord0;
            @(? (wtopt "v") [varying vec2 dispcoord0, dispcoord1;])
        ]])
        @(? (wtopt "g") [uniform sampler2D glowmap;])
        @(? (wtopt "G") [flat varying float pulse;])
        @(? (wtopt "r") [uniform samplerCube envmap; varying vec3 camvec;])
        @(? (wtopt "b") [
            uniform float blendlayer;
            uniform sampler2D blendmap;
            varying vec2 texcoord1;
        ])
        @(? (wtopt "v") [
            uniform sampler2D dispmap;
        ])

        void main(void)
        {
            vec3 normal = normalize(nvec);

            @(if (wtopt "T") [result [
                vec3 triblend = max(abs(normal) - triplanarbias.xyz, 0.001);
                triblend *= triblend;
                triblend /= triblend.x + triblend.y + triblend.z;

                @(? (wtopt "v") [
                    vec3 dispx = (texture2D(dispmap, dispcoordx0).rgb*dispcontrib.x + texture2D(dispmap, dispcoordx1).rgb*dispcontrib.y - (dispcontrib.x+dispcontrib.y)*0.5) * dispcontrib.z;
                    vec3 dispy = (texture2D(dispmap, dispcoordy0).rgb*dispcontrib.x + texture2D(dispmap, dispcoordy1).rgb*dispcontrib.y - (dispcontrib.x+dispcontrib.y)*0.5) * dispcontrib.z;
                    vec3 dispz = (texture2D(dispmap, dispcoordz0).rgb*dispcontrib.x + texture2D(dispmap, dispcoordz1).rgb*dispcontrib.y - (dispcontrib.x+dispcontrib.y)*0.5) * dispcontrib.z;
                    vec4 diffusex = texture2D(diffusemap, texcoordx + dispx.xy);
                    vec4 diffusey = texture2D(diffusemap, texcoordy + dispy.xy);
                    vec4 diffusez = texture2D(@(? (wtopt "d") "diffusedetail" "diffusemap"), texcoordz + dispz.xy);
                ] [
                    vec4 diffusex = texture2D(diffusemap, texcoordx);
                    vec4 diffusey = texture2D(diffusemap, texcoordy);
                    vec4 diffusez = texture2D(@(? (wtopt "d") "diffusedetail" "diffusemap"), texcoordz);
                ])
                vec4 diffuse = diffusex*triblend.x + diffusey*triblend.y + diffusez*triblend.z;
            ]] [result [
                @(? (wtopt "v") [
                    vec3 disp = (texture2D(dispmap, dispcoord0).rgb*dispcontrib.x + texture2D(dispmap, dispcoord1).rgb*dispcontrib.y - (dispcontrib.x+dispcontrib.y)*0.5) * dispcontrib.z;
                    vec4 diffuse = texture2D(diffusemap, texcoord0 + disp.xy);
                ] [
                    vec4 diffuse = texture2D(diffusemap, texcoord0);
                ])
            ]])

            gcolor.rgb = diffuse.rgb*colorparams.rgb;

            @(if (wtopt "r") [result [
                vec3 camvecn = normalize(camvec);
                float invfresnel = dot(camvecn, normal);
                vec3 rvec = 2.0*normal*invfresnel - camvecn;
                vec3 reflect = textureCube(envmap, rvec).rgb;
                @(? (wtopt "R") [
                    vec3 rmod = envscale.xyz*diffuse.a;
                ] [
                    #define rmod envscale.xyz
                ])
                gcolor.rgb = mix(gcolor.rgb, reflect, envmin.xyz + rmod * clamp(1.0 - invfresnel, 0.0, 1.0));
            ]])

            @(if (wtopt "g") [result [
                @(? (wtopt "T") [
                    @(? (wtopt "v") [
                        vec3 glowx = texture2D(glowmap, texcoordx + dispx.xy).rgb;
                        vec3 glowy = texture2D(glowmap, texcoordy + dispy.xy).rgb;
                        vec3 glowz = texture2D(glowmap, texcoordz + dispz.xy).rgb;
                    ] [
                        vec3 glowx = texture2D(glowmap, texcoordx).rgb;
                        vec3 glowy = texture2D(glowmap, texcoordy).rgb;
                        vec3 glowz = texture2D(glowmap, texcoordz).rgb;
                    ])
                    vec3 glow = glowx*triblend.x + glowy*triblend.y + glowz*triblend.z;
                ] [
                    @(? (wtopt "v") [
                        vec3 glow = texture2D(glowmap, texcoord0 + disp.xy).rgb;
                    ] [
                        vec3 glow = texture2D(glowmap, texcoord0).rgb;
                    ])
                ])
                glow *= @(? (wtopt "G") [mix(glowcolor.xyz, pulseglowcolor.xyz, pulse)] [glowcolor.xyz]);
                @(? (wtopt "m") [
                    glow *= diffuse.a * colorparams.a;
                ])
                @(if (wtopt "a") [result [
                    gglow.rgb = glow;
                ]] [gglowpack glow packnorm])
            ]] [? (wtopt "a") [
                gglow.rgb = vec3(0.0);
            ]])

            @(if (wtopt "a") [
                if (wtopt "A") [result [
                    vec3 rlight = gfetch(refractlight, gl_FragCoord.xy).rgb;
                    @(? (wtopt "m") [
                        gcolor.rgb *= diffuse.a;
                        gglow.rgb += rlight * refractparams.xyz * (1.0 - colorparams.a * diffuse.a);
                    ] [
                        gglow.rgb += rlight * refractparams.xyz * (1.0 - colorparams.a);
                    ])
                ]] [? (wtopt "m") [
                    gcolor.rgb *= diffuse.a;
                    #define packnorm diffuse.a * colorparams.a
                ] [
                    #define packnorm colorparams.a
                ]]
            ])

            @(gnormpackdef normal packnorm)

            @(gdepthpackfrag (|| $msaalight [&& $msaasamples [! (wtopt "a")]]) "" hashid)

            @(? (wtopt "b") [
                float blend = abs(texture2D(blendmap, texcoord1).r - blendlayer);
                gcolor.rgb *= blend;
                gnormal.rgb *= blend;
                gnormal.a *= blendlayer;
            ])

            @(gspecpack [gloss.x] (if (wtopt "s") [? (wtopt "S") [diffuse.a*specscale.x] [specscale.x]]) (? (wtopt "b") blendlayer) blend)
        }
    ]
]

worldshaders = []

// 1:<hints>
findworldshader = [
    listfind i $worldshaders [
        && [= (strlen $arg1) (strlen (at $i 1))] [strhaschars $arg1 (at $i 1)]
    ]
]

worldshader = [
    worldtype = $arg2
    stype = $SHADER_WORLD
    if (wtopt "e") [
        stype = (| $stype $SHADER_ENVMAP)
    ]
    if (wtopt "T") [
        stype = (| $stype $SHADER_TRIPLANAR)
    ]
    defershader $stype $arg1 [
        worldvariantshader @arg1 @arg2
        worldvariantshader @arg1 @(concatword $arg2 "b")
        worldvariantshader @arg1 @(concatword $arg2 "a")
        worldvariantshader @arg1 @(concatword $arg2 "aA")
    ]

    append worldshaders [[@@arg1 @@arg2]]
]

worldshader "stdworld" ""
forceshader "stdworld"

worldshader "alphaworld" "m"

worldshader "dispworld" "v"

worldshader "specworld" "s"
worldshader "specmapworld" "sS"
worldshader "specdispworld" "sv"
worldshader "specmapdispworld" "sSv"

worldshader "glowworld" "g"
worldshader "alphaglowworld" "mg"
worldshader "pulseglowworld" "gG"
worldshader "alphapulseglowworld" "mgG"
worldshader "glowdispworld" "gv"
worldshader "alphaglowdispworld" "mgv"
worldshader "pulseglowdispworld" "gGv"
worldshader "alphapulseglowdispworld" "mgGv"

worldshader "envworld" "er"
worldshader "envspecworld" "esr"
worldshader "envspecmapworld" "esSrR"
worldshader "envglowworld" "erg"
worldshader "envpulseglowworld" "ergG"
worldshader "envdispworld" "erv"
worldshader "envspecdispworld" "esrv"
worldshader "envspecmapdispworld" "esSrRv"
worldshader "envglowdispworld" "ergv"
worldshader "envpulseglowdispworld" "ergGv"

worldshader "triplanarworld" "T"
worldshader "triplanardetailworld" "Td"
worldshader "triplanardispworld" "Tv"
worldshader "triplanardetaildispworld" "Tdv"

// bumptype:
//    e -> reserve envmap texture slot
//    r -> envmap reflection
//    R -> modulate envmap reflection with spec map
//    s -> spec
//    S -> spec map
//    p -> parallax
//    g -> glow
//    G -> pulse glow
//    b -> blendmap
//    a -> transparent
//    A -> refractive
//    m -> alpha-mask
//    T -> triplanar
//    d -> detail
//    v -> displacement

btopt = [ >= (strstr $bumptype $arg1) 0 ]

bumpvariantshader = [
    local bumptype
    bumptype = $arg2
    stype = $SHADER_WORLD
    if (btopt "e") [
        stype = (| $stype $SHADER_ENVMAP)
    ]
    srow = -1
    if (btopt "G") [
        stype = (| $stype $SHADER_DYNAMIC)
        defuniformparam "glowcolor" 1 1 1 // glow color
        defuniformparam "pulseglowspeed" 1     // pulse frequency (Hz)
        defuniformparam "pulseglowcolor" 0 0 0 // pulse glow color
        defuniformparam "pulseglowoffset" 0 // pulse glow offset
    ] [if (btopt "g") [
        defuniformparam "glowcolor" 1 1 1  // glow color
    ]]
    defuniformparam "gloss" 1 // glossiness
    if (btopt "S") [
        defuniformparam "specscale" 2 2 2 // spec map multiplier
    ] [if (btopt "s") [
        defuniformparam "specscale" 1 1 1 // spec multiplier
    ]]
    if (btopt "p") [
        defuniformparam "parallaxscale" 0.06 -0.03 // parallax scaling
    ]
    if (btopt "R") [
        defuniformparam "envmin" 0 0 0 // minimum reflectivity
        defuniformparam "envscale" 1 1 1 // reflectivity map multiplier
    ] [if (btopt "r") [
        defuniformparam "envmin" 0 0 0 // minimum reflectivity
        defuniformparam "envscale" 0.2 0.2 0.2 // reflectivity
    ]]
    if (btopt "T") [
        defuniformparam "triplanarbias" 0.3 0.3 0.3
        stype = (| $stype $SHADER_TRIPLANAR)
    ]
    defuniformparam "normalscale" 1
    if (btopt "b") [
        srow = 0
    ]
    if (btopt "a") [
        if (btopt "A") [stype = (| $stype $SHADER_REFRACT)]
        srow = 1
    ]
    if (btopt "v") [
        defuniformparam "dispscale" 0.125 0.125 0.125 0.125 // displacement scale modifier
        defuniformparam "dispscroll" 0.0 0.125 0.25 -0.25 // displacement scroll modifier
        defuniformparam "dispcontrib" 1.0 1.0 0.125 // displacement texture contribution
    ]
    variantshader $stype $arg1 $srow [
        attribute vec4 vvertex, vtangent;
        attribute vec3 vnormal;
        attribute vec2 vtexcoord0;
        uniform mat4 camprojmatrix;
        uniform vec2 texgenscroll;
        uniform vec3 rotate;
        @(ginterpvert (|| $msaalight [&& $msaasamples [! (btopt "a")]] [btopt "A"]))
        @(if (btopt "T") [result [
            uniform vec2 texgenscale;
            varying vec2 texcoordx, texcoordy, texcoordz;
            @(? (btopt "v") [varying vec2 dispcoordx0, dispcoordy0, dispcoordz0, dispcoordx1, dispcoordy1, dispcoordz1;])
            varying vec3 normal;
            varying vec3 tangentx, tangenty, tangentz;
            @(? (btopt "d") [uniform vec2 detailscale;])
        ]] [result [
            varying vec2 texcoord0;
            @(? (btopt "v") [varying vec2 dispcoord0, dispcoord1;])
            varying mat3 world;
        ]])
        @(? (|| (btopt "p") (btopt "r") (btopt "T")) [
            uniform vec3 camera;
            varying vec3 camvec;
        ])
        @(? (btopt "G") [flat varying float pulse;])
        @(? (btopt "b") [
            uniform vec4 blendmapparams;
            varying vec2 texcoord1;
        ])
        @(? (|| (btopt "G") (btopt "v")) [uniform float millis;])

        void main(void)
        {
            gl_Position = camprojmatrix * vvertex;

            @(gdepthpackvert (|| $msaalight [&& $msaasamples [! (btopt "a")]] [btopt "A"]))

            @(if (btopt "T") [result [
                texcoordx = vec2(vvertex.y, -vvertex.z) * texgenscale;
                texcoordy = vec2(vvertex.x, -vvertex.z) * texgenscale;
                texcoordz = vvertex.xy * @(? (btopt "d") "detailscale" "texgenscale");
                @(? (btopt "v") [
                    dispcoordx0 = (texcoordx + millis*dispscroll.xy) * dispscale.xy;
                    dispcoordy0 = (texcoordy + millis*dispscroll.xy) * dispscale.xy;
                    dispcoordz0 = (texcoordz + millis*dispscroll.xy) * dispscale.xy;
                    dispcoordx1 = (texcoordx + millis*dispscroll.zw) * dispscale.zw;
                    dispcoordy1 = (texcoordy + millis*dispscroll.xw) * dispscale.zw;
                    dispcoordz1 = (texcoordz + millis*dispscroll.xw) * dispscale.zw;
                ])

                normal = vnormal;
                tangentx = normalize(vec3(1.001, 0.0, 0.0) - vnormal*vnormal.x);
                tangenty = normalize(vec3(0.0, 1.001, 0.0) - vnormal*vnormal.y);
                tangentz = normalize(vec3(0.0, 0.0, -1.001) + vnormal*vnormal.z);
            ]] [result [
                texcoord0 = vtexcoord0 + texgenscroll;
                @(rottexcoord texcoord0 rotate)
                @(? (btopt "v") [
                    dispcoord0 = (texcoord0 + millis*dispscroll.xy) * dispscale.xy;
                    dispcoord1 = (texcoord0 + millis*dispscroll.xw) * dispscale.zw;
                ])

                vec3 bitangent = cross(vnormal, vtangent.xyz) * vtangent.w;
                // calculate tangent -> world transform
                world = mat3(vtangent.xyz, bitangent, vnormal);
            ]])

            @(? (|| (btopt "p") (btopt "r") (btopt "T")) [
                camvec = camera - vvertex.xyz;
            ])

            @(? (btopt "b") [
                texcoord1 = (vvertex.xy - blendmapparams.xy)*blendmapparams.zw;
            ])

            @(? (btopt "G") [
                pulse = abs(fract((millis+pulseglowoffset.x)*pulseglowspeed.x)*2.0 - 1.0);
            ])
        }
    ] [
        @(if (btopt "A") [result [
            @(gfetchdefs [refractlight refractmask])
            uniform vec4 refractparams;
            uniform float refractdepthscale;
        ]])
        uniform vec4 colorparams;
        uniform sampler2D diffusemap, normalmap;
        uniform vec3 rotate;
        @(? (|| $msaalight [&& $msaasamples [! (btopt "a")]]) [uniform float hashid;])
        varying mat3 world;
        @(ginterpfrag (|| $msaalight [&& $msaasamples [! (btopt "a")]] [btopt "A"]))
        @(if (btopt "T") [result [
            varying vec2 texcoordx, texcoordy, texcoordz;
            @(? (btopt "v") [varying vec2 dispcoordx0, dispcoordy0, dispcoordz0, dispcoordx1, dispcoordy1, dispcoordz1;])
            varying vec3 normal, tangentx, tangenty, tangentz;
            @(? (btopt "d") [uniform sampler2D diffusedetail, normaldetail;])
        ]] [result [
            varying vec2 texcoord0;
            @(? (btopt "v") [varying vec2 dispcoord0, dispcoord1;])
        ]])
        @(? (|| (btopt "p") (btopt "r") (btopt "T")) [varying vec3 camvec;])
        @(? (btopt "g") [uniform sampler2D glowmap;])
        @(? (btopt "G") [flat varying float pulse;])
        @(? (btopt "r") [uniform samplerCube envmap;])
        @(? (btopt "b") [
            uniform float blendlayer;
            uniform sampler2D blendmap;
            varying vec2 texcoord1;
        ])
        @(? (btopt "v") [
            uniform sampler2D dispmap;
        ])

        void main(void)
        {
            @(? (|| (btopt "p") (btopt "r") (btopt "T")) [
                vec3 camvecn = normalize(camvec);
            ])

            #define scaledbump(map, tc) mix(vec3(0.5, 0.5, 1.0), texture2D(map, tc).rgb, normalscale.x)

            @(if (btopt "T") [result [
                vec3 triblend = max(abs(normal) - triplanarbias.xyz, 0.001);
                triblend *= triblend;
                triblend /= triblend.x + triblend.y + triblend.z;

                #define worldx mat3(tangenty, tangentz, normal)
                #define worldy mat3(tangentx, tangentz, normal)
                #define worldz mat3(tangentx, tangenty, normal)

                @(? (btopt "v") [
                    vec3 dispx = (texture2D(dispmap, dispcoordx0).rgb*dispcontrib.x + texture2D(dispmap, dispcoordx1).rgb*dispcontrib.y - (dispcontrib.x+dispcontrib.y)*0.5) * dispcontrib.z;
                    vec3 dispy = (texture2D(dispmap, dispcoordy0).rgb*dispcontrib.x + texture2D(dispmap, dispcoordy1).rgb*dispcontrib.y - (dispcontrib.x+dispcontrib.y)*0.5) * dispcontrib.z;
                    vec3 dispz = (texture2D(dispmap, dispcoordz0).rgb*dispcontrib.x + texture2D(dispmap, dispcoordz1).rgb*dispcontrib.y - (dispcontrib.x+dispcontrib.y)*0.5) * dispcontrib.z;
                ])

                @(if (btopt "p") [result [
                    @(? (btopt "v") [
                        float heightx = texture2D(normalmap, texcoordx + dispx.xy).a;
                        float heighty = texture2D(normalmap, texcoordy + dispy.xy).a;
                        float heightz = texture2D(@(? (btopt "d") "normaldetail" "normalmap"), texcoordz + dispz.xy).a;
                    ] [
                        float heightx = texture2D(normalmap, texcoordx).a;
                        float heighty = texture2D(normalmap, texcoordy).a;
                        float heightz = texture2D(@(? (btopt "d") "normaldetail" "normalmap"), texcoordz).a;
                    ])
                    vec3 camvect = camvecn * mat3(tangentx, tangenty, tangentz);

                    vec2 dtcx = texcoordx + camvect.yz*(heightx*parallaxscale.x + parallaxscale.y);
                    vec2 dtcy = texcoordy + camvect.xz*(heighty*parallaxscale.x + parallaxscale.y);
                    vec2 dtcz = texcoordz + camvect.xy*(heightz*parallaxscale.x + parallaxscale.y);
                ]] [result [
                    #define dtcx texcoordx
                    #define dtcy texcoordy
                    #define dtcz texcoordz
                ]])

                @(? (btopt "v") [
                    vec4 diffusex = texture2D(diffusemap, dtcx + dispx.xy);
                    vec4 diffusey = texture2D(diffusemap, dtcy + dispy.xy);
                    vec4 diffusez = texture2D(@(? (btopt "d") "diffusedetail" "diffusemap"), dtcz + dispz.xy);
                    vec3 bumpx = (scaledbump(normalmap, dtcx + dispx.xy)*2.0 - 1.0)*triblend.x;
                    vec3 bumpy = (scaledbump(normalmap, dtcy + dispy.xy)*2.0 - 1.0)*triblend.y;
                    vec3 bumpz = (scaledbump(@(? (btopt "d") "normaldetail" "normalmap"), dtcz + dispz.xy)*2.0 - 1.0)*triblend.z;
                ] [
                    vec4 diffusex = texture2D(diffusemap, dtcx);
                    vec4 diffusey = texture2D(diffusemap, dtcy);
                    vec4 diffusez = texture2D(@(? (btopt "d") "diffusedetail" "diffusemap"), dtcz);
                    vec3 bumpx = (scaledbump(normalmap, dtcx)*2.0 - 1.0)*triblend.x;
                    vec3 bumpy = (scaledbump(normalmap, dtcy)*2.0 - 1.0)*triblend.y;
                    vec3 bumpz = (scaledbump(@(? (btopt "d") "normaldetail" "normalmap"), dtcz)*2.0 - 1.0)*triblend.z;
                ])

                vec4 diffuse = diffusex*triblend.x + diffusey*triblend.y + diffusez*triblend.z;
                vec3 bumpw = normalize(worldx*bumpx + worldy*bumpy + worldz*bumpz);

                @(? (btopt "A") [
                    vec2 bump = bumpx.xy + bumpy.xy + bumpz.xy;
                ])
            ]] [result [
                @(? (btopt "v") [
                    vec3 disp = (texture2D(dispmap, dispcoord0).rgb*dispcontrib.x + texture2D(dispmap, dispcoord1).rgb*dispcontrib.y - (dispcontrib.x+dispcontrib.y)*0.5) * dispcontrib.z;
                ])

                @(? (btopt "p") [
                    @(? (btopt "v") [
                        float height = texture2D(normalmap, texcoord0 + disp.xy).a;
                    ] [
                        float height = texture2D(normalmap, texcoord0).a;
                    ])
                    vec2 pcoord = (camvecn * world).xy;
                    @(rottexcoord pcoord rotate)
                    vec2 dtc = texcoord0 + pcoord*(height*parallaxscale.x + parallaxscale.y);
                ] [
                    #define dtc texcoord0
                ])

                @(? (btopt "v") [
                    vec4 diffuse = texture2D(diffusemap, dtc + disp.xy);
                    @(? (&& (btopt "a") [btopt "m"]) [
                        vec4 normal = texture2D(normalmap, dtc + disp.xy);
                        normal.rgb = mix(vec3(0.5, 0.5, 1.0), normal.rgb, normalscale.x);
                        #define bump normal.rgb
                    ] [
                        vec3 bump = scaledbump(normalmap, dtc + disp.xy);
                    ])
                ] [
                    vec4 diffuse = texture2D(diffusemap, dtc);
                    @(? (&& (btopt "a") [btopt "m"]) [
                        vec4 normal = texture2D(normalmap, dtc);
                        normal.rgb = mix(vec3(0.5, 0.5, 1.0), normal.rgb, normalscale.x);
                        #define bump normal.rgb
                    ] [
                        vec3 bump = scaledbump(normalmap, dtc);
                    ])
                ])

                bump = bump*2.0 - 1.0;
                vec3 bumpw = normalize(world * bump);
            ]])

            gcolor.rgb = diffuse.rgb*colorparams.rgb;

            @(if (btopt "r") [result [
                float invfresnel = dot(camvecn, bumpw);
                vec3 rvec = 2.0*bumpw*invfresnel - camvecn;
                vec3 reflect = textureCube(envmap, rvec).rgb;
                @(? (btopt "R") [
                    vec3 rmod = envscale.xyz*diffuse.a;
                ] [
                    #define rmod envscale.xyz
                ])
                gcolor.rgb = mix(gcolor.rgb, reflect, envmin.xyz + rmod * clamp(1.0 - invfresnel, 0.0, 1.0));
            ]])

            @(if (btopt "g") [result [
                @(? (btopt "T") [
                    @(? (btopt "v") [
                        vec3 glowx = texture2D(glowmap, dtcx + dispx.xy).rgb;
                        vec3 glowy = texture2D(glowmap, dtcy + dispy.xy).rgb;
                        vec3 glowz = texture2D(glowmap, dtcz + dispz.xy).rgb;
                    ] [
                        vec3 glowx = texture2D(glowmap, dtcx).rgb;
                        vec3 glowy = texture2D(glowmap, dtcy).rgb;
                        vec3 glowz = texture2D(glowmap, dtcz).rgb;
                    ])
                    vec3 glow = glowx*triblend.x + glowy*triblend.y + glowz*triblend.z;
                ] [
                    @(? (btopt "v") [
                        vec3 glow = texture2D(glowmap, dtc + disp.xy).rgb;
                    ] [
                        vec3 glow = texture2D(glowmap, dtc).rgb;
                    ])
                ])
                glow *= @(? (btopt "G") [mix(glowcolor.xyz, pulseglowcolor.xyz, pulse)] [glowcolor.xyz]);
                @(if (btopt "a") [result [
                    gglow.rgb = glow;
                ]] [gglowpack glow packnorm])
            ]] [? (btopt "a") [
                gglow.rgb = vec3(0.0);
            ]])

            @(if (btopt "a") [
                if (btopt "A") [result [
                    vec2 rtc = bump.xy*refractparams.w;
                    float rmask = clamp(refractdepthscale*(lineardepth - dot(gfetch(refractmask, gl_FragCoord.xy + rtc).rgb, gdepthunpackparams)), 0.0, 1.0);
                    vec3 rlight = gfetch(refractlight, gl_FragCoord.xy + rtc*rmask).rgb;
                    @(? (btopt "m") [
                        gcolor.rgb *= normal.a;
                        gglow.rgb += rlight * refractparams.xyz * (1.0 - colorparams.a * normal.a);
                    ] [
                        gglow.rgb += rlight * refractparams.xyz * (1.0 - colorparams.a);
                    ])
                ]] [? (btopt "m") [
                    gcolor.rgb *= normal.a;
                    #define packnorm normal.a * colorparams.a
                ] [
                    #define packnorm colorparams.a
                ]]
            ])

            @(gnormpackdef bumpw packnorm)

            @(gdepthpackfrag (|| $msaalight [&& $msaasamples [! (btopt "a")]]) "" hashid)

            @(? (btopt "b") [
                float blend = abs(texture2D(blendmap, texcoord1).r - blendlayer);
                gcolor.rgb *= blend;
                gnormal.rgb *= blend;
                gnormal.a *= blendlayer;
            ])

            @(gspecpack [gloss.x] (if (btopt "s") [? (btopt "S") [diffuse.a*specscale.x] [specscale.x]]) (? (btopt "b") blendlayer) blend)
        }
    ]
]

bumpshader = [
    bumptype = $arg2
    stype = $SHADER_WORLD
    if (btopt "e") [
        stype = (| $stype $SHADER_ENVMAP)
    ]
    if (btopt "T") [
        stype = (| $stype $SHADER_TRIPLANAR)
    ]
    defershader $stype $arg1 [
        bumpvariantshader @arg1 @arg2
        bumpvariantshader @arg1 @(concatword $arg2 "b")
        bumpvariantshader @arg1 @(concatword $arg2 "a")
        bumpvariantshader @arg1 @(concatword $arg2 "aA")
    ]

    // Includes "n" to differentiate from the non-bump shaders
    append worldshaders [[@@arg1 n@@arg2]]
]

bumpshader "bumpworld" ""
bumpshader "bumpspecworld" "s"
bumpshader "bumpspecmapworld" "sS"
bumpshader "bumpdispworld" "v"
bumpshader "bumpspecdispworld" "sv"
bumpshader "bumpspecmapdispworld" "sSv"

bumpshader "bumpalphaworld" "m"
bumpshader "bumpspecalphaworld" "sm"
bumpshader "bumpspecmapalphaworld" "sSm"
bumpshader "bumpalphadispworld" "mv"
bumpshader "bumpspecalphadispworld" "smv"
bumpshader "bumpspecmapalphadispworld" "sSmv"

bumpshader "bumpglowworld" "g"
bumpshader "bumpspecglowworld" "sg"
bumpshader "bumpspecmapglowworld" "sSg"
bumpshader "bumpglowdispworld" "gv"
bumpshader "bumpspecglowdispworld" "sgv"
bumpshader "bumpspecmapglowdispworld" "sSgv"

bumpshader "bumppulseglowworld" "gG"
bumpshader "bumpspecpulseglowworld" "sgG"
bumpshader "bumpspecmappulseglowworld" "sSgG"
bumpshader "bumppulseglowdispworld" "gGv"
bumpshader "bumpspecpulseglowdispworld" "sgGv"
bumpshader "bumpspecmappulseglowdispworld" "sSgGv"

bumpshader "bumpparallaxworld" "p"
bumpshader "bumpspecparallaxworld" "ps"
bumpshader "bumpspecmapparallaxworld" "psS"
bumpshader "bumpparallaxdispworld" "pv"
bumpshader "bumpspecparallaxdispworld" "psv"
bumpshader "bumpspecmapparallaxdispworld" "psSv"

bumpshader "bumpparallaxglowworld" "pg"
bumpshader "bumpspecparallaxglowworld" "psg"
bumpshader "bumpspecmapparallaxglowworld" "psSg"
bumpshader "bumpparallaxglowdispworld" "pgv"
bumpshader "bumpspecparallaxglowdispworld" "psgv"
bumpshader "bumpspecmapparallaxglowdispworld" "psSgv"

bumpshader "bumpparallaxpulseglowworld" "pgG"
bumpshader "bumpspecparallaxpulseglowworld" "psgG"
bumpshader "bumpspecmapparallaxpulseglowworld" "psSgG"
bumpshader "bumpparallaxpulseglowdispworld" "pgGv"
bumpshader "bumpspecparallaxpulseglowdispworld" "psgGv"
bumpshader "bumpspecmapparallaxpulseglowdispworld" "psSgGv"

bumpshader "bumpenvworld" "er"
bumpshader "bumpenvspecworld" "esr"
bumpshader "bumpenvspecmapworld" "esSrR"
bumpshader "bumpenvdispworld" "erv"
bumpshader "bumpenvspecdispworld" "esrv"
bumpshader "bumpenvspecmapdispworld" "esSrRv"

bumpshader "bumpenvglowworld" "erg"
bumpshader "bumpenvspecglowworld" "eosrg"
bumpshader "bumpenvspecmapglowworld" "esSrRg"
bumpshader "bumpenvglowdispworld" "ergv"
bumpshader "bumpenvspecglowdispworld" "eosrgv"
bumpshader "bumpenvspecmapglowdispworld" "esSrRgv"

bumpshader "bumpenvpulseglowworld" "eorgG"
bumpshader "bumpenvspecpulseglowworld" "esrgG"
bumpshader "bumpenvspecmappulseglowworld" "esSrRgG"
bumpshader "bumpenvpulseglowdispworld" "eorgGv"
bumpshader "bumpenvspecpulseglowdispworld" "esrgGv"
bumpshader "bumpenvspecmappulseglowdispworld" "esSrRgGv"

bumpshader "bumpenvparallaxworld" "epr"
bumpshader "bumpenvspecparallaxworld" "epsr"
bumpshader "bumpenvspecmapparallaxworld" "epsSrR"
bumpshader "bumpenvparallaxdispworld" "eprv"
bumpshader "bumpenvspecparallaxdispworld" "epsrv"
bumpshader "bumpenvspecmapparallaxdispworld" "epsSrRv"

bumpshader "bumpenvparallaxglowworld" "eprg"
bumpshader "bumpenvspecparallaxglowworld" "epsrg"
bumpshader "bumpenvspecmapparallaxglowworld" "epsSrRg"
bumpshader "bumpenvparallaxglowdispworld" "eprgv"
bumpshader "bumpenvspecparallaxglowdispworld" "epsrgv"
bumpshader "bumpenvspecmapparallaxglowdispworld" "epsSrRgv"

bumpshader "bumpenvparallaxpulseglowworld" "eprgG"
bumpshader "bumpenvspecparallaxpulseglowworld" "epsrgG"
bumpshader "bumpenvspecmapparallaxpulseglowworld" "epsSrRgG"
bumpshader "bumpenvparallaxpulseglowdispworld" "eprgGv"
bumpshader "bumpenvspecparallaxpulseglowdispworld" "epsrgGv"
bumpshader "bumpenvspecmapparallaxpulseglowdispworld" "epsSrRgGv"

bumpshader "triplanarbumpworld" "T"
bumpshader "triplanarbumpspecworld" "Ts"
bumpshader "triplanarbumpspecmapworld" "TsS"
bumpshader "triplanarbumpparallaxworld" "Tp"
bumpshader "triplanarbumpdispworld" "Tv"
bumpshader "triplanarbumpspecdispworld" "Tsv"
bumpshader "triplanarbumpspecmapdispworld" "TsSv"
bumpshader "triplanarbumpparallaxdispworld" "Tpv"

bumpshader "triplanarbumpspecparallaxworld" "Tps"
bumpshader "triplanarbumpspecmapparallaxworld" "TpsS"
bumpshader "triplanarbumpspecparallaxdispworld" "Tpsv"
bumpshader "triplanarbumpspecmapparallaxdispworld" "TpsSv"

bumpshader "triplanardetailbumpworld" "Td"
bumpshader "triplanardetailbumpspecworld" "Tds"
bumpshader "triplanardetailbumpspecmapworld" "TdsS"
bumpshader "triplanardetailbumpparallaxworld" "Tdp"
bumpshader "triplanardetailbumpdispworld" "Tdv"
bumpshader "triplanardetailbumpspecdispworld" "Tdsv"
bumpshader "triplanardetailbumpspecmapdispworld" "TdsSv"
bumpshader "triplanardetailbumpparallaxdispworld" "Tdpv"

bumpshader "triplanardetailbumpspecparallaxworld" "Tdps"
bumpshader "triplanardetailbumpspecmapparallaxworld" "TdpsS"
bumpshader "triplanardetailbumpspecparallaxdispworld" "Tdpsv"
bumpshader "triplanardetailbumpspecmapparallaxdispworld" "TdpsSv"

bumpshader "triplanarbumpenvworld" "Ter"
bumpshader "triplanarbumpenvspecworld" "Tesr"
bumpshader "triplanarbumpenvspecmapworld" "TesSrR"
bumpshader "triplanarbumpenvparallaxworld" "Tepr"
bumpshader "triplanarbumpenvdispworld" "Terv"
bumpshader "triplanarbumpenvspecdispworld" "Tesrv"
bumpshader "triplanarbumpenvspecmapdispworld" "TesSrRv"
bumpshader "triplanarbumpenvparallaxdispworld" "Teprv"

bumpshader "triplanarbumpenvspecparallaxworld" "Tepsr"
bumpshader "triplanarbumpenvspecmapparallaxworld" "TepsSrR"
bumpshader "triplanarbumpenvspecparallaxdispworld" "Tepsrv"
bumpshader "triplanarbumpenvspecmapparallaxdispworld" "TepsSrRv"

bumpshader "triplanardetailbumpenvworld" "Tder"
bumpshader "triplanardetailbumpenvspecworld" "Tdesr"
bumpshader "triplanardetailbumpenvspecmapworld" "TdesSrR"
bumpshader "triplanardetailbumpenvparallaxworld" "Tdepr"
bumpshader "triplanardetailbumpenvdispworld" "Tderv"
bumpshader "triplanardetailbumpenvspecdispworld" "Tdesrv"
bumpshader "triplanardetailbumpenvspecmapdispworld" "TdesSrRv"
bumpshader "triplanardetailbumpenvparallaxdispworld" "Tdeprv"

bumpshader "triplanardetailbumpenvspecparallaxworld" "Tdepsr"
bumpshader "triplanardetailbumpenvspecmapparallaxworld" "TdepsSrR"
bumpshader "triplanardetailbumpenvspecparallaxdispworld" "Tdepsrv"
bumpshader "triplanardetailbumpenvspecmapparallaxdispworld" "TdepsSrRv"

shader $SHADER_DEFAULT "smworld" [
    attribute vec4 vvertex;
    uniform mat4 shadowmatrix;
    void main(void)
    {
        gl_Position = shadowmatrix * vvertex;
    }
] [
    void main(void)
    {
    }
]

// shadowmaptype:
//    a -> transparent
//    m -> alpha-mask
//    n -> normalmap

smtopt = [ >= (strstr $shadowmaptype $arg1) 0 ]

shadowmapworldvariantshader = [
    local shadowmaptype
    shadowmaptype = $arg2
    srow = -1
    if (smtopt "m") [
        srow = 0
    ]
    if (smtopt "n") [
        srow = 1
    ]
    variantshader $SHADER_WORLD $arg1 $srow [
        attribute vec4 vvertex;

        attribute vec2 vtexcoord0;
        uniform vec2 texgenscroll;
        uniform vec4 colorparams;
        varying vec2 texcoord0;

        uniform mat4 shadowmatrix;

        void main(void)
        {
            gl_Position = shadowmatrix * vvertex;

            texcoord0 = vtexcoord0 + texgenscroll;
        }
    ] [
        uniform vec4 colorparams;
        uniform sampler2D diffusemap;
        varying vec2 texcoord0;

        @(? (smtopt "n") [
            uniform sampler2D normalmap;
        ])

        @(? (smtopt "a") [
            uniform float shadowopacity;
        ])

        fragdata(0) vec4 gcolor;

        void main(void)
        {
            vec4 diffuse = texture2D(diffusemap, texcoord0);

            @(if (smtopt "a") [result [
                float alpha = colorparams.a;
                @(if (smtopt "m") [result [
                    @(? (smtopt "n") [
                        alpha *= texture2D(normalmap, texcoord0).a;
                    ] [
                        alpha *= diffuse.a;
                    ])
                ]])
                #define mask alpha * shadowopacity
            ]] [result [
                #define alpha 1.0
                #define mask 1.0
            ]])

            gcolor.rgb = mix(vec3(1.0), diffuse.rgb*colorparams.rgb, alpha) * (1.0 - mask);
            gcolor.a = alpha;
        }
    ]
]

shadowmapshader = [
    defershader $SHADER_WORLD $arg1 [
        shadowmapworldvariantshader @arg1 @arg2
        shadowmapworldvariantshader @arg1 @(concatword $arg2 "m")
        shadowmapworldvariantshader @arg1 @(concatword $arg2 "mn")
    ]
]

shadowmapshader "smalphaworld" "a"

defershader $SHADER_WORLD "rsmworld" [
  loop i 2 [
    variantshader $SHADER_WORLD "rsmworld" (- $i 1) [
        attribute vec4 vvertex;
        attribute vec3 vnormal;
        attribute vec2 vtexcoord0;
        uniform mat4 rsmmatrix;
        uniform vec2 texgenscroll;
        uniform vec4 colorparams;
        uniform vec3 rsmdir;
        varying vec4 normal;
        varying vec2 texcoord0;
        @(? (= $i 1) [
            uniform vec4 blendmapparams;
            varying vec2 texcoord1;
        ])
        void main(void)
        {
            gl_Position = rsmmatrix * vvertex;
            texcoord0 = vtexcoord0 + texgenscroll;
            @(if (= $i 1) [result [
                texcoord1 = (vvertex.xy - blendmapparams.xy)*blendmapparams.zw;
            ]])
            normal = vec4(vnormal, dot(vnormal, rsmdir));
        }
    ] [
        uniform vec4 colorparams;
        uniform sampler2D diffusemap;
        varying vec4 normal;
        varying vec2 texcoord0;
        @(? (= $i 1) [
            uniform float blendlayer;
            uniform sampler2D blendmap;
            varying vec2 texcoord1;
        ])
        fragdata(0) vec4 gcolor;
        fragdata(1) vec4 gnormal;
        void main(void)
        {
            vec4 diffuse = texture2D(diffusemap, texcoord0);

            @(if (= $i 2) [result [
                #define alpha 1.0
            ]] [result [
                #define alpha colorparams.a
            ]])

            gcolor.rgb = normal.w*diffuse.rgb*colorparams.rgb;
            gnormal = vec4(normal.xyz*0.5+0.5, 0.0);

            @(if (= $i 1) [result [
                float blend = abs(texture2D(blendmap, texcoord1).r - blendlayer);
                gcolor.rgb *= blend;
                gcolor.a = blendlayer;
                gnormal *= blend;
            ]] [result [
                gcolor.a = alpha;
            ]])
        }
    ]
  ]
]

