// sets descriptions for commands/variables/etc
// usage: setdesc <id> <description> "usage"
setdesc "kick" "kicks a player from the server with an optional reason" "<cn> [<text>]"
setdesc "allow" "sets a ban exemption for a player on the server" "<cn>"
setdesc "ban" "bans a player from the server with an optional reason" "<cn> [<text>]"
setdesc "mute" "mutes a player on the server with an optional reason" "<cn> [<text>]"
setdesc "limit" "limits team changing for a player on the server" "<cn>"
setdesc "spectator" "put a player to spectator mode;^n0 = join/unquarantine, 1 = spectate, 2 = spectate and quarantine" "<mode> [<cn>]"
setdesc "quit" "quits the game"
setdesc "connect" "connect to a multiplayer server" "<IP or hostname> <port> <admin or server password>"
setdesc "version" "game version for scripts" "<version>"
setdesc "servertype" "type of server, 1 = private (does not register with masterserver), 2 = public, 3 = dedicated" "<value>"
setdesc "hasoctapaks" "mega hack;^ntry to find Cube 2, done after our own data so as to not clobber stuff" "<value>"
setdesc "autosavebackups" "make backups;^n0 = off, 1 = single backup, 2 = named backup, 3/4 = same as 1/2 with move to ^"backups/^"" "<value>"
setdesc "autoreloading" "0 = never, 1 = when empty, 2 = weapons that don't add a full clip, 3 = always (+1 zooming weaps too)" "<value>"
setdesc "skipspawnweapon" "skip spawnweapon;^n0 = never, 1 = if numweaps > 1 (+1), 3 = if carry > 0 (+2), 6 = always" "<value>"
setdesc "skipmelee" "skip melee;^n0 = never, 1 = if numweaps > 1 (+2), 4 = if carry > 0 (+2), 7 = if carry > 0 and is offset (+2), 10 = always" "<value>"
setdesc "skippistol" "skip pistol;^n0 = never, 1 = if numweaps > 1 (+2), 4 = if carry > 0 (+2), 7 = if carry > 0 and is offset (+2), 10 = always" "<value>"
setdesc "skipgrenade" "skip grenade;^n0 = never, 1 = if numweaps > 1 (+2), 4 = if carry > 0 (+2), 7 = if carry > 0 and is offset (+2), 10 = always" "<value>"
setdesc "weapselectslot" "determines how weapons are selected using the number keys;^n0 = by global weapon numbers, 1 = by temporary pickup slot numbers" "<bool>"
setdesc "showaiinfo" "determines how much info is shown for bots;^n0 = hide bot info, 1 = show bot joins/parts, 2 = show more verbose info" "<value>"
setdesc "demoautoclientsave" "determines if the client automatically saves demos after each match" "<value>"
setdesc "demolock" "determines who may record demos;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder" "<value>"
setdesc "democount" "determines the maximum amount of demo files that may be saved simultaneously on the server (deletes old demos if exceeded)" "<value>"
setdesc "demomaxsize" "determines the maximum size of individual demo files that may be saved on the server" "<kilobytes>"
setdesc "demoautorec" "determines if demos are automatically recorded each match" "<value>"
setdesc "demoautoserversave" "determines if the server automatically saves demos to disk" "<value>"
setdesc "demoserverkeeptime" "if greater than 0, only keep auto-recorded demos younger than demoserverkeeptime seconds" "<value>"
setdesc "listdemos" "get a list of recorded demos available for download" ""
setdesc "getdemo" "get the demo <id> and save to the name <name>, id defaults to the last and name defaults to the current time" "[<id>] [<name>]"
setdesc "mastermode" "set a specific mode to the server;^n0 = open (everybody can join), 1 = veto (vetolock determines who can force a vote), 2 = locked (only moderator or higher can spawn), 3 = private (only global privs and players with the password can join the server)" "<value>"
setdesc "masterlock" "determines who can set mastermode;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "<value>"
setdesc "spawneditlock" "determines who may spawn during editing when mastermode = 2 (lock), but not make changes to the map;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "<value>"
setdesc "editlock" "determines who may spawn during editing when mastermode = 2 (lock);^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "<value>"
setdesc "speclock" "determines who may force players to spectate;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "<value>"
setdesc "crclock" "determines who may use maps with an incorrect CRC integrity check;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "<value>"
setdesc "kicklock" "determines who may kick players;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "<value>"
setdesc "allowlock" "determines who may allow players;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "<value>"
setdesc "banlock" "determines who may ban players;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "<value>"
setdesc "mutelock" "determines who may mute players;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "<value>"
setdesc "limitlock" "determines who may limit players;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "<value>"
setdesc "vetolock" "determines who may force match votes;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "<value>"
setdesc "floodlock" "enables flood protection for everyone below a specific privilege level;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "<value>"
setdesc "floodmute" "automatically mute player when warned this many times" "<value>"
setdesc "floodtime" "time span to check for floody messages" "<value>"
setdesc "floodlines" "number of lines in floodtime span before too many" "<value>"
setdesc "autospectate" "determines when the game switches automatically to spectate mode;^n0 = when idle, 1 = when remaining dead for autospecdelay" "<bool>"
setdesc "resetallowsonend" "determines when the allow list is reset;^n0 = off, 1 = just when empty, 2 = when matches end" "<value>"
setdesc "resetbansonend" "determines when the ban list is reset;^n0 = off, 1 = just when empty, 2 = when matches end" "<value>"
setdesc "resetmutesonend" "determines when the mute list is reset;^n0 = off, 1 = just when empty, 2 = when matches end" "<value>"
setdesc "resetlimitsonend" "determines when the limit list is reset;^n0 = off, 1 = just when empty, 2 = when matches end" "<value>"
setdesc "resetvarsonend" "determines when these game variables are reset;^n0 = off, 1 = just when empty, 2 = when matches end" "<value>"
setdesc "resetmmonend" "determines when privilege mode changes are reset;^n0 = off, 1 = just when empty, 2 = when matches end" "<value>"
setdesc "gamespeedlock" "determines if gamespeed is locked (also limited by varslock);^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "<value>"
setdesc "rotatemodefilter" "determines the modes which can be selected when the server selects the next map,^nconvenient to set using a sum of $modebit* vars (available: editing, deathmatch, capture, defend, bomber, race),^nexample: (+ $modebitediting $modebitdeathmatch)" "<sum>"
setdesc "rotatemuts" "determines if mutators rotate when the server selects the next map;^n0 = never rotate mutators, 1 = always rotate mutators, >1 = decrease chances the larger this value" "<value>"
setdesc "rotatemutsfilter" "determines the mutators which can be selected when the server selects the next map,^nconvenient to set using a sum of $mutsbit* vars (available: multi, ffa, coop, instagib, medieval, kaboom, duel, survivor, classic, onslaught, freestyle, vampire, hard, resize, gsp1 = first mode variation {ctf-quick, dac-quick, bb-hold, tt-marathon}, gsp2 = second mode variation {ctf-defend, dac-king, bb-basket, tt-endurance}, gsp3 = third mode variation {ctf-protect, bb-attack, tt-gauntlet}),^nexample: (+ $mutsbitmulti $mutsbitffa)" "<sum>"
setdesc "kingmaps" "king-of-the-hill maps" "<list>"
setdesc "multimaps" "maps allowed for modes which *require* multi spawns (ctf/bb)" "<list>"
setdesc "modelock" "determines at which privilege level modes are locked, according to modelocktype;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "<value>"
setdesc "modelocktype" "determines the mode locking type;^n0 = off, 1 = lock level only, 2 = lock level can set limited mode and higher" "<value>"
setdesc "mapsfilter" "0 = off, 1 = filter based on mutators, 2 = also filter based on players" "<value>"
setdesc "mapslock" "determines at which privilege level maps are locked, according to mapslocktype;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "<value>"
setdesc "mapslocktype" "determines the maps locking type;^n0 = off, 1 = lock level only, 2 = lock level can select non-rotation" "<value>"
setdesc "varslock" "determines if vars are locked;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "<value>"
setdesc "votelock" "determines at which privilege level votes are locked, according to votelocktype;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "<value>"
setdesc "votelocktype" "determines the vote locking type;^n0 = off, 1 = lock level only, 2 = lock level can select prevmaps" "<value>"
setdesc "votewait" "time in milliseconds before a player may cast another vote (to avoid flooding)" "<milliseconds>"
setdesc "votestyle" "determines how mid-match votes are handled;^n0 = votes don't pass mid-match, 1 = passes if votethreshold is met, 2 = passes if unanimous" "<milliseconds>"
setdesc "votethreshold" "auto-pass votes when this many agree" "<value>"
setdesc "voteinterm" "0 = must wait entire time, 1 = passes if votethreshold is met, 2 = passes if unanimous" "<value>"
setdesc "smallmapmax" "maximum number of players for a small map" "<value>"
setdesc "mediummapmax" "maximum number of players for a medium map" "<value>"
setdesc "maxalive" "only allow this*numplayers (for current map) to be alive at once" "<value>"
setdesc "maxalivequeue" "toggle queue system (used if number of players exceeds maxalive*numplayers for current map);^n0 = prohibits leaving spectator, 1 = players enter queue" "<value>"
setdesc "maxaliveminimum" "only enables maxalive limit if the number of players is more than or equal to this" "<value>"
setdesc "maxalivethreshold" "only enables maxalive limit if the number of players is more than or equal to this*numplayers (for current map)" "<value>"
setdesc "spawnrotate" "spawn point rotation;^n0 = let client decide, 1 = sequence, 2 = random" "<value>"
setdesc "spawngrenades" "spawn with grenades;^n0 = never, 1 = all but instagib/race, 2 = always" "<value>"
setdesc "spawnmines" "spawn with mines;^n0 = never, 1 = all but instagib/race, 2 = always" "<value>"
setdesc "spawndelay" "time in milliseconds before players can respawn in most modes" "<millisecond>"
setdesc "instadelay" "time in milliseconds before players can respawn in instagib mutated modes" "<milliseconds>"
setdesc "racedelay" "time in milliseconds before players can respawn in race mode" "<milliseconds>"
setdesc "racedelayex" "time in milliseconds before defenders can respawn in gauntlet mode" "<milliseconds>"
setdesc "bomberdelay" "delay before spawning in bomber" "<millisecond>"
setdesc "spawnprotect" "time in milliseconds after spawning players cannot be damaged" "<milliseconds>"
setdesc "duelprotect" "time in milliseconds after spawning players cannot be damaged in duel/survivor matches" "<milliseconds>"
setdesc "instaprotect" "time in milliseconds after spawning players cannot be damaged in instagib matches" "<milliseconds>"
setdesc "instaresizeamt" "each kill adds this much size in insta-resize" "<value>"
setdesc "regendelay" "time in milliseconds after being damage before normal regeneration resumes" "<milliseconds>"
setdesc "regentime" "time in milliseconds for which regenerate gives health" "<milliseconds>"
setdesc "regenhealth" "amount of health regeneration gives" "<value>"
setdesc "regendecay" "if over maxhealth, decay this amount each regen" "<value>"
setdesc "kamikaze" "determines the level of kamikaze events;^n0 = never, 1 = holding grenade, 2 = have grenade, 3 = always" "<value>"
setdesc "itemsallowed" "determines if items are present in the level;^n0 = never, 1 = all but instagib, 2 = always" "<value>"
setdesc "itemspawntime" "time in milliseconds before items (re)spawn" "<milliseconds>"
setdesc "itemspawndelay" "time in milliseconds after map start items first spawn" "<milliseconds>"
setdesc "itemspawnstyle" "determines the timing of item spawning at map start;^n0 = all at once, 1 = staggered, 2 = random, 3 = randomise between both" "<value>"
setdesc "itemthreshold" "if numitems/(players*maxcarry) is less than this, spawn one of this type" "<value>"
setdesc "timelimit" "time in minutes before round ends;^n0 = off" "<minutes>"
setdesc "overtimeallow" "if scores are equal, go into overtime" "<value>"
setdesc "overtimelimit" "maximum time overtime may last, 0 = forever" "<minutes>"
setdesc "intermlimit" "time in milliseconds intermission lasts" "<milliseconds>"
setdesc "votelimit" "time in milliseconds intermission voting lasts" "<milliseconds>"
setdesc "duelreset" "determines if duel/survivor winner should be sent back to respawn for next round" "<value>"
setdesc "duelclear" "determines if items are reset at the end of each round" "<value>"
setdesc "duelcooloff" "cool off period before duel goes to next round" "<milliseconds>"
setdesc "duelcycle" "determines if players are force-cycled after a certain number of wins (0 = off, 1 = non-team games, 2 = team games, 3 = both)" "<value>"
setdesc "duelcycles" "maximum wins in a row before force-cycling (0 = num team/total players)" "<value>"
setdesc "damageself" "determines if the player can damage themselves;^n0 = off, 1 = either hurt self or use damageteam rules" "<value>"
setdesc "damageselfscale" "determines how much self-damage is dealt;^n0 = off, anything else = scale for damage" "<value>"
setdesc "damageteam" "determines if the player can damage team members;^n0 = off, 1 = non-bots damage team, 2 = all players damage team" "<value>"
setdesc "damageteamscale" "determines how much team damage is dealt;^n0 = off, anything else = scale for damage" "<value>"
setdesc "teambalance" "determines the method of team balancing;^n0 = off, 1 = by number then rank, 2 = by rank then number" "<value>"
setdesc "teampersist" "when a player leaves and rejoins the game, automatically put them on the same team they had before;^n0 = off, 1 = only attempt, 2 = forced" "<value>"
setdesc "pointlimit" "number of points required to end the round (and win) in deathmatch modes" "<value>"
setdesc "capturelimit" "number of captures required to end the round (and win) in ctf" "<value>"
setdesc "capturepoints" "points added to score for capturing flag" "<value>"
setdesc "capturepickuppoints" "points added to score for picking up enemy flag" "<value>"
setdesc "capturethreshold" "automatically drop the flag if the flag-carrier ^"warps^" more than this distance" "<distance>"
setdesc "capturebuffing" "buff circumstances;^n0 = off, &1 = near own flag at its base, &2 = near own loose flag, &4 = holding own flag, &8 = near teammate holding own flag, &16 = holding enemy flag, &32 = near teammate holding enemy flag" "<value>"
setdesc "capturebuffdelay" "buffed when guarding, and for this long after" "<milliseconds>"
setdesc "capturebuffarea" "multiply affinity radius by this much for buff" "<value>"
setdesc "capturebuffdamage" "multiply outgoing damage by this much when buffed" "<value>"
setdesc "capturebuffshield" "divide incoming damage by this much when buffed" "<value>"
setdesc "captureregenbuff" "0 = off, 1 = modify regeneration when buffed" "<value>"
setdesc "captureregendelay" "regen this often when buffed" "<milliseconds>"
setdesc "captureregenextra" "add this to regen when buffed" "<value>"
setdesc "defendlimit" "determines the style of dac play;^nnumber of points required to end the round (and win) in dac" "<value>"
setdesc "defendinterval" "time in milliseconds to add one tick to the secure gauge" "<milliseconds>"
setdesc "defendpoints" "number of points given in dac" "<value>"
setdesc "defendoccupy" "ticks needed to overthrow or secure a control area" "<value>"
setdesc "defendking" "ticks needed to secure in king-of-the-hill" "<value>"
setdesc "defendhold" "ticks an area must remain secured in order to score" "<value>"
setdesc "defendflags" "flags to init and how;^n0 = init all (neutral), 1 = init neutral and team only, 2 = init team only, 3 = init all (team + neutral + converted)" "<value>"
setdesc "defendbuffing" "buff circumstances;^n0 = off, &1 = when guarding, &2 = when securing, &4 = even when enemies are present" "<value>"
setdesc "defendbuffoccupy" "if defendbuffing = 4, must be occupied this much before passing" "<milliseconds>"
setdesc "defendbuffdelay" "buffed for this long after leaving" "<milliseconds>"
setdesc "defendbuffarea" "multiply affinity radius by this much for buff" "<value>"
setdesc "defendbuffdamage" "multiply outgoing damage by this much when buffed" "<value>"
setdesc "defendbuffshield" "divide incoming damage by this much when buffed" "<value>"
setdesc "defendregenbuff" "0 = off, 1 = modify regeneration when buffed" "<value>"
setdesc "defendregendelay" "regen this often when buffed" "<milliseconds>"
setdesc "defendregenextra" "add this to regen when buffed" "<value>"
setdesc "bomberlimit" "finish when score is this or more (non-hold)" "<value>"
setdesc "bomberholdlimit" "finish when score is this or more (hold)" "<value>"
setdesc "bomberpoints" "points added to score for a goal" "<value>"
setdesc "bomberpenalty" "points taken from score for throwing the bomb into your own goal" "<value>"
setdesc "bomberpickuppoints" "points added to score for picking up the bomb" "<value>"
setdesc "bomberholdpoints" "points added to score for each interval (hold)" "<value>"
setdesc "bomberholdpenalty" "points subtracted for having the bomb fuse run out (hold)" "<value>"
setdesc "bomberthreshold" "automatically drop the bomb if the bomb-carrier ^"warps^" more than this distance" "<distance>"
setdesc "bomberbuffing" "buff circumstances;^n0 = off, &1 = when near own base, &2 = when holding bomb, &4 = when holding bomb as the defenders (attack only)" "<value>"
setdesc "bomberbuffdelay" "buffed for this long after leaving" "<milliseconds>"
setdesc "bomberbuffarea" "multiply affinity radius by this much for buff" "<value>"
setdesc "bomberbuffdamage" "multiply outgoing damage by this much when buffed" "<value>"
setdesc "bomberbuffshield" "divide incoming damage by this much when buffed" "<value>"
setdesc "bomberregenbuff" "0 = off, 1 = modify regeneration when buffed" "<value>"
setdesc "bomberregendelay" "regen this often when buffed" "<milliseconds>"
setdesc "bomberregenextra" "add this to regen when buffed" "<value>"
setdesc "bombercarryspeed" "scales the movement speed of the player carrying the bomber ball by this value" "<value>"
setdesc "bombercarrytime" "time in milliseconds a player can carry the bomber ball before it explodes" "<milliseconds>"
setdesc "bomberholdinterval" "time in milliseconds a player needs to hold the ball in hold bomber-ball to get a point" "<milliseconds>"
setdesc "bomberpickupdelay" "time in milliseconds a player needs to wait to be able to pick up the bomber ball again after dropping it" "<milliseconds>"
setdesc "bomberresetdelay" "time in milliseconds before the bomber ball resets after being dropped" "<milliseconds>"
setdesc "bomberspeed" "speed at which the bomber ball moves when thrown or dropped;^nfor reference, 125 is the speed the player moves at by default" "<value>"
setdesc "botbalance" "determines bot balancing method;^n-1 = always use numplayers, 0 = don't balance, 1 or more = fill only with this*numteams" "<value>"
setdesc "enemyspawntime" "determine length of time before enemies respawn" "<milliseconds>"
setdesc "enemyspawndelay" "determine length of time after map start enemies first spawn" "<milliseconds>"
setdesc "enemyspawnstyle" "determines enemy spawning style, 0 = all at once, 1 = staggered, 2 = random, 3 = randomise between both" "<value>"
setdesc "movespeed" "baseline movement speed" "<value>"
setdesc "movecrawl" "multiplier of speed when crawling" "<value>"
setdesc "movepacing" "multiplier of speed when pacing" "<value>"
setdesc "movestraight" "multiplier of speed when only moving forward" "<value>"
setdesc "movestrafe" "multiplier of speed when strafing" "<value>"
setdesc "moveinair" "multiplier of speed when in-air" "<value>"
setdesc "movestepup" "multiplier of speed when stepping up" "<value>"
setdesc "movestepdown" "multiplier of speed when stepping down" "<value>"
setdesc "jumpspeed" "extra velocity to add when jumping" "<value>"
setdesc "impulsespeed" "extra velocity to add when impulsing" "<value>"
setdesc "impulselimit" "maximum impulse speed" "<value>"
setdesc "impulseboost" "multiplier of impulse when just boosting" "<value>"
setdesc "impulsepower" "power jump modifier" "<value>"
setdesc "impulsedash" "multiplier of impulse when dashing" "<value>"
setdesc "impulsejump" "multiplier of impulse when jumping" "<value>"
setdesc "impulseparkour" "multiplier of impulse when doing other parkour" "<value>"
setdesc "impulseparkourkick" "parkour kick modifier" "<value>"
setdesc "impulseparkourvault" "parkour vault modifier" "<value>"
setdesc "impulseparkournorm" "minimum parkour surface z normal" "<value>"
setdesc "impulsestyle" "impulse style;^n0 = off, 1 = touch and count, 2 = count only, 3 = freestyle" "<value>"
setdesc "impulsecount" "number of impulse actions per air transit" "<value>"
setdesc "impulseslip" "time before floor friction kicks back in" "<milliseconds>"
setdesc "impulseslide" "time before powerslides end" "<milliseconds>"
setdesc "impulsedelay" "minimum time between boosts" "<milliseconds>"
setdesc "impulsedashdelay" "minimum time between dashes/powerslides" "<milliseconds>"
setdesc "impulsekickdelay" "minimum time between wall kicks/climbs" "<milliseconds>"
setdesc "impulsevaultmin" "minimum percentage of height for vault" "<value>"
setdesc "impulsevaultmax" "maximum percentage of height for vault" "<value>"
setdesc "impulsemelee" "multiplier of impulse when using melee" "<value>"
setdesc "impulsemeter" "impulse dash length;^n0 = unlimited, anything else = timer" "<value>"
setdesc "impulsecost" "cost of impulse jump" "<value>"
setdesc "impulseskate" "length of time a run along a wall can last" "<value>"
setdesc "impulsepacing" "pacing counts toward impulse;^n0 = off, anything else = multiplier of time" "<value>"
setdesc "impulseregen" "impulse regen multiplier" "<value>"
setdesc "impulseregencrouch" "impulse regen modifier when crouching" "<value>"
setdesc "impulseregenpacing" "impulse regen modifier when pacing" "<value>"
setdesc "impulseregenmove" "impulse regen modifier when moving" "<value>"
setdesc "impulseregeninair" "impulse regen modifier when in air" "<value>"
setdesc "impulseregendelay" "delay before impulse regens" "<value>"
setdesc "zoomlock" "0 = unrestricted, 1 = must be on floor, 2 = also must not be moving, 3 = also must be on flat floor, 4 = must also be crouched" "<value>"
setdesc "zoomlocktime" "time before zoomlock kicks in when in the air" "<milliseconds>"
setdesc "autoscores" "1 = when dead, 2 = also in spectv, 3 = and in waittv too" "<value>"
setdesc "scoresdelay" "otherwise use respawn delay" "<milliseconds>"
setdesc "showlaptimes" "0 = off, 1 = only player, 2 = +humans, 3 = +bots" "<value>"
setdesc "muzzleflash" "0 = off, 1 = only other players, 2 = only thirdperson, 3 = all" "<value>"
setdesc "muzzleflare" "0 = off, 1 = only other players, 2 = only thirdperson, 3 = all" "<value>"
setdesc "underlaydisplay" "0 = only firstperson and alive, 1 = only when alive, 2 = always" "<value>"
setdesc "overlaydisplay" "0 = only firstperson and alive, 1 = only when alive, 2 = always" "<value>"
setdesc "showdamage" "1 shows just damage texture, 2 blends as well" "<value>"
setdesc "showcrosshair" "0 = off, 1 = on, 2 = blend depending on current accuracy level" "<value>"
setdesc "crosshairweapons" "0 = off, 1 = crosshair-specific weapons, 2 = also appy colour" "<value>"
setdesc "cursorstyle" "0 = top left tracking, 1 = center" "<value>"
setdesc "inventorybgskew" "skew items inside by this much" "<value>"
setdesc "inventorybgspace" "for aligning diagonals" "<value>"
setdesc "inventoryhealth" "0 = off, 1 = text, 2 = bar, 3 = bar + text" "<value>"
setdesc "inventoryhealthbartop" "starts from this offset" "<value>"
setdesc "inventoryhealthbarbottom" "ends at this offset" "<value>"
setdesc "inventoryimpulsebartop" "starts from this offset" "<value>"
setdesc "inventoryimpulsebarbottom" "ends at this offset" "<value>"
setdesc "inventorystatus" "0 = off, 1 = text, 2 = icon, 3 = icon + tex" "<value>"
setdesc "radarstyle" "0 = compass-sectional, 1 = compass-distance, 2 = screen-space, 3 = right-corner-positional" "<value>"
setdesc "radaraspect" "0 = off, else = (for radarstyle 0/1) radar forms an ellipse" "<value>"
setdesc "radardist" "0 = use world size" "<value>"
setdesc "radarcornerdist" "0 = use world size" "<value>"
setdesc "radarplayerfilter" "0 = off, 1 = non-team, 2 = team, 3 = only in duel/survivor/edit" "<value>"
setdesc "radardamage" "0 = off, 1 = basic damage, 2 = with killer announce (+1 killer track, +2 and bots), 5 = verbose" "<value>"
setdesc "editradarstyle" "0 = compass-sectional, 1 = compass-distance, 2 = screen-space, 3 = right-corner-positional" "<value>"
setdesc "editradardist" "0 = use world size" "<value>"
setdesc "animationinterpolationtime" "sets the duration in milliseconds of animation blending" "<value>"
setdesc "addpostfx" "adds this effect to the post-processing stack" "<value>"
setdesc "setpostfx" "replaces all the current post-processing effects with this one" "<value>"
setdesc "clearpostfx" "clears all post-processing effects"
setdesc "motionblurfx" "0 = off, 1 = on, 2 = override" "<value>"
setdesc "motionblurmin" "minimum" "<value>"
setdesc "motionblurmax" "maximum" "<value>"
setdesc "motionbluramt" "used for override" "<value>"
setdesc "musictype" "0 = no in-game music, 1 = map music (or random if none), 2 = always random, 3 = map music (silence if none), 4-5 = same as 1-2 but pick new tracks when done" "<value>"
setdesc "musicedit" "0 = no editing music, 1 = map music (or random if none), 2 = always random, 3 = map music (silence if none), 4-5 = same as 1-2 but pick new tracks when done" "<value>"
setdesc "followdead" "0 = never, 1 = in all but duel/survivor, 2 = always" "<value>"
setdesc "specmode" "0 = float, 1 = tv" "<value>"
setdesc "waitmode" "0 = float, 1 = tv in duel/survivor, 2 = tv always" "<value>"
setdesc "spectvrotate" "rotate style, < 0 = absolute angle, 0 = scaled, > 0 = scaled with max angle" "<value>"
setdesc "spectvdead" "0 = never, 1 = in all but duel/survivor, 2 = always" "<value>"
setdesc "deathcamstyle" "0 = no follow, 1 = follow attacker, 2 = follow self" "<value>"
setdesc "zoomdefault" "0 = last used, else defines default level" "<value>"
setdesc "zoomscroll" "0 = stop at min/max, 1 = go to opposite end" "<value>"
setdesc "showobituaries" "0 = off, 1 = only me, 2 = 1 + announcements, 3 = 2 + but dying bots, 4 = 3 + but bot vs bot, 5 = all" "<value>"
setdesc "obitannounce" "0 = off, 1 = only focus, 2 = everyone" "<value>"
setdesc "obitverbose" "0 = extremely simple, 1 = simplified per-weapon, 2 = regular messages" "<value>"
setdesc "obitstyles" " 0 = no obituary styles, 1 = show sprees/dominations/etc" "<value>"
setdesc "showpresence" "0 = never show join/leave, 1 = show only during game, 2 = show when connecting/disconnecting" "<value>"
setdesc "showteamchange" "0 = never show, 1 = show only when switching between, 2 = show when entering match too" "<value>"
setdesc "deathanim" "0 = hide player when dead, 1 = old death animation, 2 = ragdolls" "<value>"
setdesc "deathfade" "0 = don't fade out dead players, 1 = fade them out" "<value>"
setdesc "deathscale" "0 = don't scale out dead players, 1 = scale them out" "<value>"
setdesc "gravity" "gravity" "<value>"
setdesc "impulsekick" "determines the minimum angle to switch between wall kick and run" "<angle>"
setdesc "impulsemethod" "determines which impulse method to use, 0 = none, 1 = power jump, 2 = power slide, 3 = both" "<value>"
setdesc "impulseaction" "determines how impulse action works, 0 = off, 1 = impulse jump, 2 = impulse dash, 3 = both" "<value>"
setdesc "impulseroll" "determines the camera angle tilt when wallrunning" "<angle>"
setdesc "dashstyle" "0 = only with impulse, 1 = double tap" "<value>"
setdesc "crouchstyle" "0 = press and hold, 1 = double-tap toggle, 2 = toggle" "<value>"
setdesc "pacingstyle" "0 = press and hold, 1 = double-tap toggle, 2 = toggle, 3-5 = same, but auto engage if impulsepacing == 0" "<value>"
setdesc "showentdir" "0 = off, 1 = only selected, 2 = always when editing, 3 = always in editmode" "<value>"
setdesc "aboveheadblend" "determines the opacity of all abovehead* vars" "<value>"
setdesc "aboveheaddamage" "shows amount of damage done to a player above their head" "<value>"
setdesc "aboveheadeventsize" "determines the size of event icons above players' heads" "<value>"
setdesc "aboveheadicons" "detemines what type of actions displays icons above player (bitwise OR for affinities and weapons);^n0 = none, 1+ = damage & kill events, 2 = affinity pickups, 4 = weapons pickups" "<value>"
setdesc "aboveheadiconssize" "determines the size of icons handled by aboveheadicons" "<value>"
setdesc "aboveheadnames" "toggles the display of player names above their heads" "<value>"
setdesc "aboveheadnamessize" "determines the size of names for aboveheadnames" "<value>"
setdesc "aboveheadstatus" "toggles display of player status above players' heads, player status is dominating, dominated, death" "<value>"
setdesc "aboveheadstatussize" "determines the size of player status controlled by aboveheadstatus" "<value>"
setdesc "aboveheadteam" "determines how team icons are displayed above player heads;^n0 = do not show, 1 = only teammates, 2 = all teams" "<value>"
setdesc "bloodsize" "sets the size of blood splatter" "<value>"
setdesc "chatconsize" "sets the amount of lines to show in the chat console, this does not include overflow lines" "<value>"
setdesc "chatconblend" "sets the opacity of the chat console" "<value>"
setdesc "chatconscale" "determines the scaling of the chat console text" "<value>"
setdesc "commandscale" "determines the scaling of the command and chat input text" "<value>"
setdesc "conblend" "sets the opacity of the console, this does not include obituaries and affinity events! (flag, bomb)" "<value>"
setdesc "concenter" "toggles alignment of console;^n0 = console is in top left, 1 = console is centered" "<value>"
setdesc "consize" "sets the amount of lines to show in the console, this does not include overflow lines" "<value>"
setdesc "conscale" "determines the scaling of the console text" "<value>"
setdesc "dominatetex" "determines what image is used for the ^"dominating!^" event icon" "<value>"
setdesc "dominatedtex" "determines what image is used for the icon that appears over a player's head while dominating" "<value>"
setdesc "dominatingtex" "determines what image is used for the icon that appears over a player's head while being dominated" "<value>"
setdesc "eventblend" "sets the opacity of event icons, (first blood, 2x, 3x, headshot, etc.)" "<value>"
setdesc "eventiconfade" "sets how long event icons should stay on screen" "<value>"
setdesc "eventoffset" "sets the offset for the event icons in your hud, negative values move it downward, positive values move it upward" "<value>"
setdesc "eventscale" "sets the scale of event icons that appear in your hud" "<value>"
setdesc "fullconblend" "sets the opacity of the ^"full^" console, this is when the console is open, and includes obituaries and affinity events. (flag, bomb) excluding those two elements, conblend takes precedence over this variable, yet only affects everything else" "<value>"
setdesc "healthbgtex" "determines what image is used for the background of the healthbar" "<value>"
setdesc "hudblend" "sets the opacity of the entire hud as a whole, this includes both consoles, mouse pointer, and inventory" "<value>"
setdesc "hudsize" "sets the size of the entire hud as a whole, this includes both consoles, menus, inventory, etc" "<value>"
setdesc "inventoryblend" "sets the opacity of the inventory" "<value>"
setdesc "inventorycolour" "toggles the colour of the weapon icons in the weapon bar;^n0 = no colour at all, 1 = only weapon icon is coloured, 2 = both weapon icon and slot number are coloured" "<value>"
setdesc "inventoryglow" "sets the size of the ^"glow^" in the inventory, the ^"glow^" is the splatter/explosion image behind inventory items" "<value>"
setdesc "inventorybgblend" "sets the opacity of the inventory background" "<value>"
setdesc "inventoryimpulse" "sets how the impulse meter is displayed;^n0 = do not show at all, 1 = show textual percentage, 2 = show a bar meter" "<value>"
setdesc "impulsetex" "determines what image is used for the impulse meter" "<value>"
setdesc "inventoryleft" "sets the size of the inventory on the left" "<value>"
setdesc "inventoryright" "sets the size of the inventory on the right" "<value>"
setdesc "inventorytone" "sets the tone of various inventory elements;^n0 = no colouring at all, 1 = uses your profile colour, 2 = uses team colour for team games and grey when neutral, 3 = uses team colour for team games and your profile colour when neutral, 4 = uses profile colour for team games and grey when neutral" "<value>"
setdesc "inventoryweapids" "sets how to display the slot number of the weapons in the weapon bar;^n0 = do not show, 1 = show for active weapon only, 2 = show for all weapons" "<value>"
setdesc "noticescale" "sets the size of the notices" "<value>"
setdesc "zoomsensitivity" "determines aiming/look sensitivity while zoomed in with the rifle" "<value>"
setdesc "zoomtex" "determines what image is used for the scope on the rifle" "<value>"
setdesc "playerscale" "defines the size of players" "<value>"
setdesc "botscale" "defines the size of bots" "<value>"
setdesc "adminpass" "sets server admin password, if no password given, it will return the current password" "<value>"
setdesc "aiforcegun" "forces bots' weapon preference, if -1, bots have randomized weapon preferences" "<value>"
setdesc "aipassive" "sets ai to be passive, ie, non-hostile;^n0 = hostile, 1 = hostile to other AI, 2 = hostile to all" "<value>"
setdesc "captureresetdelay" "time in milliseconds before a dropped flag automatically resets" "<milliseconds>"
setdesc "maxhealth" "spawnhealth * maxhealth defines the maximum amount of health that can be reached (e.g. standing next to a friendly goal)" "<value>"
setdesc "maxhealthvampire" "spawnhealth * maxhealthvampire defines the maximum amount of health that can be reached by damaging other players in vampire" "<value>"
setdesc "minresizescale" "defines the smallest scaled size a player can become in a match with the resize mutator enabled" "<value>"
setdesc "maxresizescale" "defines the largest scaled size a player can become in a match with the resize mutator enabled" "<value>"
setdesc "maxcarry" "maximum number of weapons a player can carry, plus pistol and grenades" "<value>"
setdesc "spawnhealth" "defines the amount of health you spawn with, and the maximum amount of health to which you will regenerate when damaged, assigning this variable a value of 0 or 1 will cause you to die in one hit" "<value>"
setdesc "zoomtime" "determines how long it takes for the rifle scope to zoom in and out, the rifle uses the primary fire mode unless the scope is fully zoomed in" "<value>"
setdesc "duelmaxqueued" "number of players that can be queued for duel. 0 = any number of players"
setdesc "survivormaxqueued" "number of players that can be queued for survivor. 0 = any number of players"
//material
setdesc "editmat" "modifies the material properties for selected cubes;^n<type> is the material to be applied {water, clip, ladder, etc.},^n<filter> limits the command to only affect cubes whose material match this, if given as empty string ^"^" it matches all,^n<style> limits the command to only affect cubes whose geometry match this {0 = normal, 1 = non-empty, 2 = empty, 3 = not entirely solid, 4 = entirely solid},^nexample: editmat air water 2 would set all empty cubes with water within the current selection to instead be air" "<type> [<filter> <style>]"
setdesc "showmat" "toggles the visibility of material volumes" "<value>"
setdesc "air" "modifies the material properties for the selected cubes;^n<filter> limits the command to only affect cubes whose material match this {water, clip, ladder, etc.}" "[<filter>]"
loop i 4 [
    setdesc [water@(? $i (+ $i 1))] "modifies the material properties for the selected cubes;^n<filter> limits the command to only affect cubes whose material match this {water, clip, ladder, etc.}" "[<filter>]"
    setdesc [glass@(? $i (+ $i 1))] "modifies the material properties for the selected cubes;^n<filter> limits the command to only affect cubes whose material match this {water, clip, ladder, etc.}" "[<filter>]"
    setdesc [lava@(? $i (+ $i 1))] "modifies the material properties for the selected cubes;^n<filter> limits the command to only affect cubes whose material match this {water, clip, ladder, etc.}" "[<filter>]"
]
setdesc "clip" "modifies the material properties for the selected cubes;^n<filter> limits the command to only affect cubes whose material match this {water, clip, ladder, etc.}" "[<filter>]"
setdesc "noclip" "modifies the material properties for the selected cubes;^n<filter> limits the command to only affect cubes whose material match this {water, clip, ladder, etc.}" "[<filter>]"
setdesc "death" "modifies the material properties for the selected cubes;^n<filter> limits the command to only affect cubes whose material match this {water, clip, ladder, etc.}" "[<filter>]"
setdesc "aiclip" "modifies the material properties for the selected cubes;^n<filter> limits the command to only affect cubes whose material match this {water, clip, ladder, etc.}" "[<filter>]"
setdesc "ladder" "modifies the material properties for the selected cubes;^n<filter> limits the command to only affect cubes whose material match this {water, clip, ladder, etc.}" "[<filter>]"
setdesc "alpha" "modifies the material properties for the selected cubes;^n<filter> limits the command to only affect cubes whose material match this {water, clip, ladder, etc.}" "[<filter>]"

setdesc "checkmaps" "reports if clients are using a modified map"
setdesc "serverclients" "maximum number of allowed clients" "<value>"
setdesc "serverdesc" "server description" "<text>"
setdesc "servermotd" "server message of the day" "<text>"
setdesc "serveropen" "determines server openness for public use;^n0 = allow ^"setpriv 1^" and locked/private, 1 = allow ^"setpriv 1^" but no privileged mode, no locked/private, 2 = allow ^"setpriv 1^" but disallows private privileged mode (for public coop-editing), 3 = privilege only by moderator or above" "<value>"
setdesc "autoadmin" "determines if authorities claim status by default" "<value>"
setdesc "airefreshdelay" "delay imposed before the AI manager reorganises their setup" "<milliseconds>"
setdesc "modelockfilter" "determines the modes which are allowed to be used as dictated by modelock,^nconvenient to set using a sum of $modebit* vars (available: editing, deathmatch, capture, defend, bomber, race),^nexample: (+ $modebitediting $modebitdeathmatch)" "<sum>"
setdesc "mutslockfilter" "determines the mutators which are allowed to be used as dictated by modelock,^nconvenient to set using a sum of $mutsbit* vars (available: multi, ffa, coop, instagib, medieval, kaboom, duel, survivor, classic, onslaught, freestyle, vampire, hard, resize, gsp1 = first mode variation {ctf-quick, dac-quick, bb-hold, tt-marathon}, gsp2 = second mode variation {ctf-defend, dac-king, bb-basket, tt-endurance}, gsp3 = third mode variation {ctf-protect, bb-attack, tt-gauntlet}),^nexample: (+ $mutsbitmulti $mutsbitffa)" "<sum>"
setdesc "mutslockfilter" "determines the mutators which must always be on,^nconvenient to set using a sum of $mutsbit* vars (available: multi, ffa, coop, instagib, medieval, kaboom, duel, survivor, classic, onslaught, freestyle, vampire, hard, resize, gsp1 = first mode variation {ctf-quick, dac-quick, bb-hold, tt-marathon}, gsp2 = second mode variation {ctf-defend, dac-king, bb-basket, tt-endurance}, gsp3 = third mode variation {ctf-protect, bb-attack, tt-gauntlet}),^nexample: (+ $mutsbitffa $mutsbitinstagib)" "<sum>"
setdesc "gamespeed" "percentage of default gameplay speed" "<value>"
setdesc "gamepaused" "pauses the game, automatically unset by server" "<value>"
setdesc "defaultmap" "default map, ^"^" = random" "<map>"
setdesc "defaultmode" "default game mode;^n1 = editing, 2 = deathmatch, 3 = ctf, 4 = dac, 5 = bomber, 6 = race" "<value>"
setdesc "defaultmuts" "default mutators, convenient to set using a sum of $mutsbit* vars (available: multi, ffa, coop, instagib, medieval, kaboom, duel, survivor, classic, onslaught, freestyle, vampire, hard, resize, gsp1 = first mode variation {ctf-quick, dac-quick, bb-hold, tt-marathon}, gsp2 = second mode variation {ctf-defend, dac-king, bb-basket, tt-endurance}, gsp3 = third mode variation {ctf-protect, bb-attack, tt-gauntlet})" "<sum>"
setdesc "rotatemaps" "determines behaviour of map rotation;^n0 = off, 1 = sequence, 2 = random" "<value>"
setdesc "rotatemapsfilter" "0 = off, 1 = filter based on mutators, 2 = also filter based on players" "<value>"
setdesc "rotatemode" "determines if modes rotate when the server selects the next map" "<value>"
setdesc "allowmaps" "determines which maps are allowed to be chosen without elevated privileges" "<list>"
setdesc "mainmaps" "deathmatch maps" "<list>"
setdesc "capturemaps" "capture-the-flag maps" "<list>"
setdesc "defendmaps" "defend-the-flag maps" "<list>"
setdesc "bombermaps" "bomber-ball maps" "<list>"
setdesc "holdmaps" "hold bomber-ball maps" "<list>"
setdesc "racemaps" "race maps" "<list>"
setdesc "duelmaps" "duel map filter (extra filter on top of mode filter)" "<list>"
setdesc "spawnweapon" "weapon players spawn with, defaults to pistol (1)" "<value>"
setdesc "instaweapon" "weapon players spawn with in instagib, defaults to rifle (8)" "<value>"
setdesc "raceweapon" "weapon players spawn with in race, defaults to melee only (0)" "<value>"
setdesc "burntime" "time in milliseconds fire burns for, try to allow an extra 500ms breathing room for sync" "<milliseconds>"
setdesc "burndelay" "time in milliseconds for which fire burning deals damage" "<milliseconds>"
setdesc "burndamage" "amount of damage fire burning deals" "<value>"
setdesc "bleedtime" "time in milliseconds bleeding lasts for, try to allow an extra 500ms breathing room for sync" "<milliseconds>"
setdesc "bleeddelay" "time in milliseconds for which bleeding deals damage" "<value>"
setdesc "bleeddamage" "amount of damage bleeding deals" "<value>"
setdesc "bleedtime" "time in milliseconds shocking lasts for, try to allow an extra 500ms breathing room for sync" "<milliseconds>"
setdesc "bleeddelay" "time in milliseconds for which shocking deals damage" "<value>"
setdesc "bleeddamage" "amount of damage shocking deals" "<value>"
setdesc "botskillmin" "minimum randomly assigned AI skill level" "<value>"
setdesc "botskillmax" "maximum randomly assigned AI skill level" "<value>"
setdesc "coopskillmin" "minimum randomly assigned AI skill level in coop" "<value>"
setdesc "coopskillmax" "maximum randomly assigned AI skill level in coop" "<value>"
setdesc "enemyskillmin" "minimum randomly assigned skill level for neutral actors in onslaught" "<value>"
setdesc "enemyskillmax" "maximum randomly assigned skill level for neutral actors in onslaught" "<value>"
setdesc "botlimit" "maximum number of bots allowed, regardless of any other variable/setting" "<value>"
setdesc "enemybalance" "multiply number of enemy spawns by this much" "<value>"
setdesc "gravityscale" "multiply gravity by this much" "<value>"
setdesc "liquidspeedscale" "multiply liquidspeed by this much" "<value>"
setdesc "liquidcoastscale" "multiply liquidcoast by this much" "<value>"
setdesc "floorcoastscale" "multiply floorcoast by this much" "<value>"
setdesc "aircoastscale" "multiply aircoast by this much" "<value>"
setdesc "slidecoastscale" "multiply slidecoast by this much" "<value>"
setdesc "stillspread" "multiply projectile spread by this much when standing still" "<value>"
setdesc "movespread" "multiply projectile spread by this much when moving" "<value>"
setdesc "inairspread" "multiply projectile spread by this much when jumping/in-air" "<value>"
setdesc "impulsespread" "multiply projectile spread by this much when impulsing/running" "<value>"
setdesc "radialscale" "multiply explosion radius by this amount" "<value>"
setdesc "radiallimited" "multiply explosion radius by this amount in limited situations (eg. instagib)" "<value>"
setdesc "damagescale" "scale damage by this amount" "<value>"
setdesc "hitpushscale" "scale hit pushes by this amount" "<value>"
setdesc "hitstunscale" "multiply ^"stun target on hit^" by this amount" "<value>"
setdesc "deadpushscale" "scale hit pushes by this amount when it results in a frag" "<value>"
setdesc "wavepushscale" "scale of the hitpush force used in a wavepush" "<value>"
setdesc "kickpushscale" "multiply kick pushes from weapons by this much" "<value>"
setdesc "kickpushcrouch" "multiply kick pushes from weapons by this much when crouching" "<value>"
setdesc "kickpushsway" "multiply kick push effect on hud gun sway by this much" "<value>"
setdesc "kickpushzoom" "multiply kick pushes from weapons by this much when zoomed" "<value>"
setdesc "multikilldelay" "time in milliseconds multiple kills in a row must occur" "<value>"
setdesc "spreecount" "number of consecutive frags for each spree level" "<value>"
setdesc "dominatecount" "number of frags on a single player without revenge before it is considered domination" "<value>"
setdesc "firstpersonfov" "determines the size of the field of view in first person mode" "<angle>"
setdesc "fov" "determines the size of the field of view in first or third person mode, depending on the current camera mode" "<angle>"
//clients
setdesc "getclientnum" "returns your own client number" "<cn>"
setdesc "getclientcolour" "returns the color of a player in HEX format" "<cn>"
setdesc "getclienthandle" "returns the auth handle of a player" "<cn>"
setdesc "getclientip" "returns the ip address of a player" "<cn>"
setdesc "getclienthost" "returns the hostmask of a player" "<cn>"
setdesc "getclientmodel" "returns the model number of a player's chosen player model" "<cn>"
setdesc "getclientname" "returns the name of the player; filter: 0 = without priv icon, 1 = with priv icon^necxample: getclientname 2 1" "<cn> [<filter>]"
setdesc "getclientversion" "returns specific information of a player^nid: 0 = major version, 1 = minor version, 2 = patch version, 3 = game version, 4 = platform (0 = Windows, 1 = OS X, 2 = Unix-like), 5 = architecture^n6 = OpenGL version, 7 = OpenGL shader version, 8 = CRC checksum, 9 = GPU vendor, 10 = GPU, 11 = GPU version, 12 = platform short form^n13 = game version, platform, architecture" "<cn> <id>"
setdesc "getclientvanity" "returns the vanities of a player" "<cn>"
setdesc "getclientweapselect" "returns a player's currently selected loadout" "<cn>"
setdesc "getclientloadweap" "returns the weaponid of <slot> in the loadout of a player" "<cn> <slot>"
setdesc "getclientteam" "returns the team number of a player (1 = alpha, 2 = omega, 3 = kappa, 4 = sigma)" "<cn>"
setdesc "getmodelname" "returns the model name from a model number, the second argument determines which bits of the path to the model file is printed, defaults to 2;^n0 = path to model directory, 1 = path to model/hwep directory, name of model directory" "<modelnumber> <value>"
setdesc "listclients" "returns a list with client numbers from actual server^n boolean: 0 = Adds your cn, 1 = Adds your cn as the first item^n filter: 0 = off, 1 = enemies, 2 = all ai" "[<bool>] [<filter>]"
//editing
setdesc "newent" "create a new entity (available: light, mapmodel, playerstart, envmap, particles, sound, lightfx, sunlight, weapon, teleport, actor, trigger, pusher, affinity, checkpoint, dummy1, dummy2)" "<type> <properties...>"
setdesc "entset" "set type and properties of the currently selected entity" "<type> <properties...>"
setdesc "skylight" "set colour and brightness of a uniform downwards-facing lightsource spanning the whole sky" "<value>"
setdesc "ambient" "set colour and brightness of a uniform ambient light throughout the whole map" "<value>"
setdesc "entfind" "selects all entities of a specific type and optionally with specific properties, using ^"1^" as type selects all entities" "<type> <properties...>"
setdesc "entfindinsel" "selects all entities, within the selected area, of a specific type and optionally with specific properties, using ^"1^" as type selects all entities" "<type> <properties...>"
setdesc "entcancel" "deselects all entities while leaving area selected"
setdesc "savemap" "saves the current map as ^"mapname.mpz^" in the homedir" "<map>"
setdesc "maptitle" "sets the title message of the map" "<text>"
setdesc "mapauthor" "sets the author message of the map" "<text>"
setdesc "mapenlarge" "enlarges the map to twice the size" "<text>"
setdesc "shrinkmap" "shrinks the map size to smallest cubed area, only empty space outside of the map will be removed"
setdesc "sendmap" "manually sends map to the server"
setdesc "getmap" "manually retrieves map from the server"
setdesc "gettex" "picks up the texture from the face currently selected, note that allfaces must be turned off"
setdesc "vscale" "replaces selected textures with scaled versions, minimum is 0.125, maximum is 8" "<value>"
setdesc "vrotate" "replaces selected textures with clockwise rotated or flipped versions;^n0 = default, 1-3 = rotate 90*this degrees, 4 = flipped left-to-right, 5 = flipped top-to-bottom" "<value>"
setdesc "vcolour" "replaces selected textures with colour-tinted versions,^ne.g. 1 0.2 0.2 will create red versions, default is 1 1 1" "<red> <green> <blue>"
setdesc "vpalette" "applies the colour specified by <set> and <id> from the builtin palette;^nset 0 = pulse colours {0 = turn off all palette effects, 1 = dark fire pulse colours, 2 = bright fire pulse colours, 3 = disco pulse colours (bomber-ball)},^nset 1 = team colours {0-3 = only enforced in teamplay games 4-7 = enforced at all times},^nset 2 = weapon colours {0-9 = only enforced when that weapon is able to spawn in the current game configuration 10-19 = enforced at all times}" "<set> <id>"
setdesc "vreset" "resets a vtexture to its original settings"
setdesc "replace" "repeats the last texture change across the entire map, note that allfaces must be turned off"
setdesc "vdelta" "combines with texture v*-commands to adjust rather than overwrite the setting;^nexample: vdelta [vcolour 1 .5 .5]^nexample: vdelta [voffset 0 +16]" "<command> <settings...>"
setdesc "vshaderparam" "set shader parameters of textures;^nindependent of vdelta, only one shader parameter may be overridden per texture, previous modifications are lost^nspecscale <red> <green> <blue> = specularity colour and brightness of a texture {example: vshaderparam specscale 0.2 0.2 1.1 creates a blue shine, specscale 0.2 0.2 0.2 resets},^nparallaxscale <low> <high> = adjusts the 3d heightmap effect of a texture,^nglowcolor <red> <green> <blue> = adjusts the 3d glow colour of a texture" "<parameter> <properties>"
setdesc "vlayer" "Sets the bottom texture layer for all textures in the current selection;^n<texture_id> is the number of the texture as seen in the texture browser" "<texture_id>"
setdesc "texturecull" "removes all textures not used in the map from the map config file"
setdesc "setgrass" "designates the currently selected texture as a ^"grass texture^" throughout the whole map, and uses <file> as the vertical grass image, e.g textures/grass.png" "<file>"
setdesc "grasscolour" "sets the colour of grass" "<red> <green> <blue>"
setdesc "grassheight" "sets the height of grass" "<value>"
setdesc "grassblend" "sets the opacity of grass" "<value>"
setdesc "grassdist" "sets the distance at which grass becomes visible" "<value>"
setdesc "calclight" "create and apply lightmap for all textures"
setdesc "lightprecision" "set precision of lightmap, higher precision reduces quality and speeds up calclight"
setdesc "fullbright" "hides lightmap for all textures if enabled"
setdesc "selectbrush" "select a different brush with relative index to the current one;^n-1 = previous brush, 1 = next brush" "<index>"
setdesc "skybox" "loads a set of 6 images associated by name from the specified basepath;^ne.g. ^"skyboxes/gradient^" will load gradient_{up,dn,lf,rt,bk,ft}.{png,jpg}" "<basepath>"
setdesc "skycolour" "changes the colour of the skybox" "<red> <green> <blue>"
setdesc "yawsky" "determines the placement of the skybox (move the sun's placement)"
setdesc "spinsky" "controls the speed at which the skybox turns"
setdesc "cloudlayer" "loads a specified image to tile as a cloud layer" "<file>"
setdesc "cloudheight" "set cloud placement;^n-1 = bottom of the skybox, 1 = top of the skybox"
setdesc "cloudscale" "controls the scale of the cloud layer" "<value>"
setdesc "cloudscrollx" "controls the movement speed of the cloud layer on the x axis" "<value>"
setdesc "cloudscrolly" "controls the movement speed of the cloud layer on the y axis" "<value>"
setdesc "cloudlayercolour" "controls the colour of the cloud layer" "<red> <green> <blue>"
setdesc "cloudfade" "controls how the cloud layer fades around the edges" "<value>"
setdesc "dropwaypoints" "determines if waypoints are dropped by players in game, defaults to 1;^n0 = no waypoints are dropped, 1 = limited number of waypoints are dropped" "<value>"
setdesc "showwaypoints" "toggles the visibility of the path that connects waypoints, waypoints are always visible if they are being dropped" "<value>"
setdesc "savewaypoints" "saves a .wpt file containing the current maps waypoints, if no argument is given it uses the current map's name" "[<name>]"
setdesc "loadwaypoints" "loads a .wpt file containing waypoints, if no argument is given it loads a waypoint file matching the current map's name" "[<name>]"
setdesc "delselwaypoints" "delete the waypoints in the currently selected area"

setdesc "followaiming" "determines aim direction when following a player^n0 = don't aim, &1 = aim in thirdperson, &2 = aim in first person" "<value>"
setdesc "spectvfirstperson" "determines aim direction of spectv;^n0 = aim in direction followed player is facing, 1 = aim in direction determined by spectv when dead, 2 = always aim in direction" "<value>"
setdesc "spectvthirdperson" "determines aim direction of spectv;^n0 = aim in direction followed player is facing, 1 = aim in direction determined by spectv when dead, 2 = always aim in direction" "<value>"
setdesc "previousmaps" "list of previously played maps"
setdesc "maphistory" "remember this many maps that can't be voted again if votelock is set" "<value>"
setdesc "intermmode" "determines camera style in intermission;^n0 = float, 1 = tv" "<value>"
setdesc "coopbalance" "in coop, bot team gets this many players for each human"
setdesc "coopmultibalance" "in multi-coop, each bot team gets this many players for each human"
//gui
setdesc "newgui" "creates a new menu;^n<name> refers to the menu's variable name,^n<content> refers to the actual content of the gui itself,^n[<initscript>] is optional, and is run before the menu is created (used with ^"if (= $guipasses 0)^" to initialize variables for the menu)" "<name> <content> [<initscript>]"
setdesc "guiheader" "sets the header title of the menu, replacing the first argument of newgui in the title bar." "<value>"
setdesc "guistayopen" "Usually, clicking a button or image to trigger an action will close the menu.^nThis rule does not apply to buttons or images in a guistayopen block." "<content>"
setdesc "guitab" "creates a new tab for the current menu. Note: The first tab of each menu is already impied by newgui." "<name>"
setdesc "showgui" "shows a menu created via newgui;^n<name> refers to the menu's variable name,^n[<tab>] is the index for the tab to show (and not the tab's title)" "<name> [<tab>]"
setdesc "guicount" "Returns the number of menus in the current gui stack." ""
setdesc "cleargui" "Closes all open menus; If an integer argument is given, it goes back <value> steps in the stack of open menus." "[<value>]"
setdesc "guitext" "creates a text element;^n<text> can be a raw string or a variable,^n[<icon>] is the path to an image, example: ^"textures/chat^",^n[<colour>] is a hexadecimal colour code, example: 0xFF0000, ^n[<iconcolour>] acts on the <icon> just like <colour> acts on the <text>,^n[<wrap>] specifies a width limit, which allows the text to expand over several lines" "<text> [<icon>] [<colour>]  [<iconcolour>] [<wrap>]"
setdesc "guibutton" "creates a text button;^n<name> refers to the button's variable name,^n<action> defines what the button does,^n[<alt-act>] defines what the button does when right-clicked,^n[<icon>] is the path to an image, example: ^"textures/chat^",^n[<colour>] is a hexadecimal colour code, example: 0xFF0000" "<name> <action> [<alt-act>] [<icon>] [<colour>]"
setdesc "guiimage" "creates a clickable image;^n<path> is the path to an image, example: ^"textures/chat^",^n[<action>] defines what clicking the image does,^n[<scale>] defines the scale of the image,^n[<overlaid>] whether or not the image is overlaid with guioverlaytex (true/false),^n[<alt-path>] alternate image to use if <path> cannot be loaded,^n[<alt-act>] defines what the image does when right clicked,^n[<colour>] is a hexadecimal colour code - useful to colorize icons, e.g. for weapons or teams" "<path> [<action>] [<scale>] [<overlaid>] [<alt-path>] [<alt-act>] [<colour>]"
setdesc "guicheckbox" "creates a checkbox;^n<name> a text string shown to the right of the checkbox,^n<variable> refers to the alias/var that the checkbox controls,^n[<on>] is the value given to <variable> when the checkbox is on, and vice-versa for [<off>], if these are not specified, 1/0 is assumed,^n[<onchange>] is the action taken whenever the checkbox is toggled,^n[<colour>] is a hexadecimal colour code, example: 0xFF0000" "<name> <var> [<on>] [<off>] [<onchange>] [<colour>]"
setdesc "guiradio" "creates a radio button;^n<name> a text string shown to the right of the radio button,^n<var> refers to the alias/var that the radio button controls,^n<value> is the value given to <var> when selected,^n[<onchange>] is the action taken whenever the button is toggled,^n[<colour>] is a hexadecimal colour code, example: 0xFF0000" "<name> <var> <value> [<onchange>] [<colour>]"
setdesc "guilist" "adds <content> to a list. Guilists can be nested to arrange gui elements horizontally and vertically.^nThis also allows to structure the layout in order to use guibars, guisliders and coloured guibackgrounds." "<content>"
setdesc "guibody" "allows a list of gui elements to act like a single button;^n<content> is a block of code inside an implied guilist,^n<action> is the action taken when clicking any element of <content>^n[<alt-act>] allows to define a different right-click action,^n[<onhover>] is executed when the mouse moves over the boundary of the guibody - useful for guitooltip" "<content> <action> [<alt-act>] [<onhover>]"
setdesc "guispring" "adds weight to a menu for pushing elements more/less to one side;^nexample: guilist [ guispring ; guitext ^"centered^"; guispring ]" "[<value>]"
setdesc "guistrut" "adds spacing to a menu;^nif [<bool>] is 1, it wraps the guistrut in a guilist (adds spacing in the alternate direction),^n^"guistrut 5 1^" is the same as ^"guilist [ guistrut 5 ]^"" "<amount> [<bool>]"
setdesc "guibar" "draws either a vertical or a horizontal line, depending on the nesting of guilist" "[<size>] [<space>] [<colour>] [<border>]"
setdesc "guifont" "sets the text font to be used in a block;^n<font> is a keyword, e.g. emphasis or small^n<block> is a block of gui elements for which <font> is used^nexample: newgui font-preview [loopfiles i config/fonts cfg [guifont $i [guitext $i]]]^nnote: This will preview all of the available <font> options." "<font> <block>"
setdesc "guibackground" "creates a colored background for the current guilist;^n<colour> is in hexadecimal, example: 0xFF0000,^n[<blend>] is the opacity of the colour, ranges from 0 (invisible) to 1 (opaque),^n[<bordercolour>] is the colour of the border,^n[<borderblend>] is the opacity of the border,^n[<border>] determines if the border is drawn (0 or 1),^n[<levels>] specifies how many guilist levels to go back" "<colour> [<blend>] [<bordercolour>] [<borderblend>] [<border>]  [<levels>]"
setdesc "guifill" "creates a coloured background for the current guilist, but without the skin settings of guibackground.^nThis implies sharp corners, no borders and a blend value of 0.5;^n<colour> is in hexadecimal, example: 0xFF0000,^n[<levels>] specifies how many guilist levels to go back" "<colour> [<levels>]"
setdesc "guifield" "creates a text field;^n<var> is the variable the guifield controls,^n<maxlength> is the width in characters, negative values allow the field to expand downward,^n[<onchange>] is the action taken when the value changes,^n[<colour>] is a hex colour, e.g. 0xFF0000, ^n[<focus>] (1) will keep the input field in focus,^n[<parent>] allows to pass the input,^n[<height>] is the number of lines to show with a scroll bar,^n[<promt>] is a text shown when <var> is empty,^n[<immediate>] (1) updates <var> already while typing." "<var> <maxlength> [<onchange>] [<colour>] [<focus>] [<parent>] [<height>] [<promt>] [<immediate>]"
setdesc "guieditor" "creates a guifield with content from a text file;^n<name> is a filename,^n[<maxlength>] is the width of the field, negative values imply text wrap,^n[<height>] is the number of lines shown with a scroll bar,^n[<mode>] (4) implies read-only,^n[<colour>] is a hex code for the entire editor,^n[<focus>] (1) keeps the editor field in focus^n[<parent>] allows to pass input,^n[<str>] allows to do a textinit using <name>,^n[<prompt>] is shown when the field is empty." "<name> [<maxlength>] [<height>] [<mode>] [<colour>] [<focus>] [<parent>] [<str>] [<prompt>]"
setdesc "guikeyfield" "creates a key field (each key being a separate element);^n<var> refers to the alias/variable the guikeyfield controls,^n<maxlength> defines the maximum number of characters/length of the field, negative values allow the field to expand downward as needed,^n[<onchangge>] is the action taken when the guikeyfield value changes,^n[<colour>] is a hexadecimal colour code example: 0xFF0000" "<var> <maxlength> [<onchange>] [<colour>]"
setdesc "guibitfield" "creates a checkbox for the bitwise and of <var> and <bit>;^n<name> a text string shown to the right of the checkbox,^n<variable> refers to an alias/var that holds bitwise information,^n<bit> is the bit of <var> that the checkbox controls, given as a power of 2,^n[<onchange>] is the action taken whenever the checkbox is toggled,^n[<colour>] is a hexadecimal colour code, example: 0xFF0000.^nexample: guibitfield ^"allow votes for race games^" modelockfilter $modebitrace" "<name> <var> <bit> [<onchange>] [<colour>]"
setdesc "guislider" "creates a slider, depending on the use of guilist;^n<var> is an integer that the slider controls,^n<min> and <max> give the valid range for <var>,^n[<onchange>] is the action taken when the slider is moved,^n[<reverse>] (1) flips the slider,^n[<scroll>] (1) enables scrolling also on the parent guilist,^n[<colour>] is a hex colour (hover text),^n[<style>] (1) draws a bar instead of a point,^n[<slidercolour>] is a hex colour (bar/point).^nexample: guislider raceweapon 0 11^nsee also: guinameslider, guilistslider" "<var> <min> <max> [<onchange>] [<reverse>] [<scroll>] [<colour>] [<style>] [<slidercolour>] "
setdesc "guilistslider" "creates a slider, depending on the use of guilist;^n<var> is an integer that the slider controls,^n<list> holds the values for <var>,^n[<onchange>] is the action taken when the slider is moved,^n[<reverse>] (1) flips the slider,^n[<scroll>] (1) enables scrolling also on the parent guilist,^n[<colour>] is a hex colour (hover text),^n[<style>] (1) draws a bar instead of a point,^n[<slidercolour>] is a hex colour (bar/point).^nexample: guilistslider raceweapon [0 1 2 3 4 5 6 7 8 9 10 11]^nsee also: guinameslider" "<var> <list> [<onchange>] [<reverse>] [<scroll>] [<colour>] [<style>] [<slidercolour>] "
setdesc "guinameslider" "creates a slider, depending on the use of guilist;^n<var> is an integer that the slider controls,^n<names> is a list of hover texts shown for each value,^n<list> is a list of valid values for <var>,^n[<onchange>] is the action taken when the slider is moved,^n[<reverse>] (1) flips the slider,^n[<scroll>] (1) enables scrolling also on the parent guilist,^n[<colour>] is a hex colour (hover text),^n[<style>] (1) draws a bar instead of a point,^n[<slidercolour>] is a hex colour.^nexample: guinameslider raceweapon $weapname [0 1 2 3 4 5 6 7 8 9 10 11]" "<var> <names> [<list>] [<onchange>] [<reverse>] [<scroll>] [<colour>] [<style>] [<slidercolour>] "
setdesc "guimodelpreview" "shows a preview of a mapmodel^n<model> is a subdirectory^n[<animspec>] is the name of an associated animation,^n[<action>] allows to use the preview as a button,^n[<scale>] is the preview image size, ^n[<overlaid>] (1) draws a frame (guioverlaytex),^n[<size>] is a scaling or zoom factor,^n[<blend>] is for opacity,^n[<alt-act>] defines an action for right-clicking"  "<model> [<animspec>] [<action>] [<scale>] [<overlaid>] [<size>] [<blend>] [<altact>]"
setdesc "guiplayerpreview" "shows a preview of a player model;^n[<model>] is 0 (male) or 1 (female),^n[<colour>] is the player colour,^n[<team>] is the team index (0-4),^n[<weap>] is a weapon id (0-11),^n[<vanity>] is a list of vanity item names,^n[<action>] allows to use the preview as a button,^n[<scale>] is the preview image size, ^n[<overlaid>] (1) draws a frame (guioverlaytex),^n[<size>] is a scaling or zoom factor,^n[<blend>] is for opacity,^n[<alt-act>] defines an action for right-clicking" "<model> <colour> <team> <weap> <vanity> [<action>] [<scale>] [<overlaid>] [<size>] [<blend>] [<altact>]"
setdesc "guiprogress" "draws an animated progress icon, as shown when loading a map;^n<value> is converted to a percentage and used as an overlay text,^n[<size>] is the image size for the progress icon" "<value> [<size>]"
setdesc "guislice" "creates a slice (pie-chart) of an image with overlaid text;^n[<path>] is the path to an image, example: ^"textures/chat^" ,^n[<action>] is executed when clicking the image,^n[<scale>] is the size of the image,^n[<start>] and [<end>] give the range of the slice. For a full rotation, use 0 1,^n[<text>] is an overlay text,^n[<altpath>] is used when <path> cannot be loaded,^n[<altact>] allows to specify a different right-click action" "[<path>] [<action>] [<scale>] [<start>] [<end>] [<text>] [<altpath>] [<altact>]"
setdesc "guinohitfx" "Hover effects are disabled for all buttons or images in a guinohitfx block.^nThis is useful for images that do not act as buttons." "<content>"
setdesc "guitooltip" "creates a text box attached to the mouse pointer;^n<text> is the hover text,^n[<width>] adjusts the width of the box,^nexample: if (=s $guirolloveraction ^"disconnect^") [guitooltip ^"leave the current game (server)^"]" "<text> [<width>]"
setdesc "guirollovername" "Returns the text label or image path of the gui element at the current mouse position." ""
setdesc "guirolloveraction" "Returns the <action> of a button or image or the <var> of a checkbox or radio at the current mouse position." ""
setdesc "guirollovertype" "Returns the type of the gui element at the current mouse position, e.g. text, image or checkbox." ""

setdesc "setpersist" "toggles an alias as persistent, that is, determines if it will be added to config.cfg;^n<bool>: 0 = not persistent, 1 = persistent" "<alias> <bool>"
setdesc "local" "declares a set of aliases as local to the alias (function) it was declared in"
setdesc "alias" "defines a new alias (variable or command block);^n example: alias pi 3.14159265359^nis equivalent to: pi = 3.14159265359" "<name> <contents>"
setdesc "getalias" "looks up the contents of an alias;^nexample: echo (getalias dm)^nis equivalent to: echo $dm" "<name>"
setdesc "inputcommand" "prepares input to the command line;^n<init> is the input string,^n[<action>] is an optional command to execute after inputcommand,^n[<icon>] is an optional icon to use next to the input (example: ^"textures/chat^"),^n[<colour>] is an optional color of <icon>,^n[<flags>] are optional command flags to pass {c = CF_COMPLETE, x = CF_EXECUTE, s = CF_COMPLETE|CF_EXECUTE (default)}" "<init> [<action>] [<icon>] [<colour>] [<flags>]"
setdesc "setcomplete" "Enables (or disables) tab-completion of a command;^n<name> is the name of a command or alias,^n[<bool>] (1) enables completion of <name> (the dafault is 0, disabled)." "<name> [<bool>]"
setdesc "listcomplete" "Enables tab-completion of a command's first argument;^n<name> is a command or alias,^n<list> is a list of valid arguments to be completed" "<name> <list>"
setdesc "complete" "Enables tab-completion for files as argument of a command;^n<name> is a command or alias,^n[<path>] is a directory to look for the files, note the <path> is not contained in the auto-completed argument,^n<extension> allows to pick only a certain file type, and will omit the extension when completing file names.^nexample: complete guifont config/fonts cfg" "<name> [<path>] [<extension>]"
//binds
setdesc "bind" "binds an action to a key. WARNING: This overrides existing binds for that key;^n<key> is a key, for example KP1 or RETURN,^n<action> is a command to be executed when the key is pressed,^nexample: bind O [echo O was pressed ... ; onrelease [echo ... and released]]" "<key> <action>"
setdesc "editbind" "binds an edit mode action to a key. WARNING: This overrides existing edit binds for that key;^n<key> is a key, for example KP1 or RETURN,^n<action> is a command to be executed when the key is pressed in edit mode." "<key> <action>"
setdesc "specbind" "binds a spectator mode action to a key. WARNING: This overrides existing spectator binds for that key;^n<key> is a key, for example KP1 or RETURN,^n<action> is a command to be executed when the key is pressed in spectator mode." "<key> <action>"
setdesc "getbind" "returns the command associated with a given key bind;^n<key> is a key, for example KP1 or RETURN." "<key>"
setdesc "geteditbind" "returns the command associated with a given key bind for edit mode;^n<key> is a key, for example KP1 or RETURN." "<key>"
setdesc "getspecbind" "returns the command associated with a given key bind for spectator mode;^n<key> is a key, for example KP1 or RETURN." "<key>"
setdesc "searchbinds" "finds key binds for a given action;^nthis is used by the dobindsearch alias" "<action> [<formatting options>]"
setdesc "searcheditbinds" "finds edit key binds for a given action;^nthis is used by the dobindsearch alias" "<action> [<formatting options>]"
setdesc "searchspecbinds" "finds spectator key binds for a given action;^nthis is used by the dobindsearch alias" "<action> [<formatting options>]"
setdesc "dobindsearch" "prints out a nicely formatted string with the key binds for a given action;^n<action> is the action to search for,^n[<mode>] can be edit or spec to search for the corresponding mode specific binds." "<key> [<mode>]"

setdesc "loop" "executes <body> with <var> incremented from 0 to <count>-1;^nexample: loop i 10 [ echo $i ]" "<var> <count> <body>"
setdesc "loopconcat" "returns a string with the result of the <body> concatenated with <var> incremented from 0 to <count>-1;^nexample: loopconcat i 10 [ result $i ]" "<var> <count> <body>"
setdesc "loopconcatword" "returns a string with the result of the <body> concatword-ed with <var> incremented from 0 to <count>-1;^nexample: loopconcatword i 10 [ result $i ]" "<var> <count> <body>"
setdesc "loopfiles" "executes <body> with <var> set to each file in <directory> with the given <extension> (^"^" for extension is all files);^nexample: loopfiles f data cfg [ echo $f ]" "<var> <directory> <extension> <body>"
setdesc "looplist" "executes <body> with <var> set to each item in <list>;^nexample: looplist i ^"this is a list^" [ echo $i ]" "<var> <list> <body>"
setdesc "loopwhile" "executes <body> with <var> incremented from 0 to <count>-1 while <condition> is true;^nexample: loopwhile i 10 [ < $i 5 ] [ echo $i ]" "<var> <count> <condition> <body>"
setdesc "while" "executes <body> while <cond> is true;^nexample: i = 0; while [ < $i 10 ] [ echo $i; i = (+ $i 1) ]" "<cond> <body>"
//lists
setdesc "indexof" "returns the index in <list> of <data>;^nexample: indexof ^"this is a list^" list" "<list> <data>"
setdesc "listdel" "returns the <list1> with all occurrences of each element in <list2> removed, it is equivalent to set difference;^nexample: listdel ^"this list has duplicates^" ^"this duplicates^", will return ^"list has^"" "<list1> <list2>"
setdesc "listfind" "returns the index in <list> where the <body> returns true, similar to looplist;^nexample: listfind i ^"this is a list^" [ result (>= (stringstr $i l) 0) ]" "<var> <list> <body>"
setdesc "listlen" "returns the length of the <list>;^nexample: listlen ^"this is a list^"" "<list>"
setdesc "listsplice" "returns a list where the elements between the <start> index and the end or for <count> elements is replaced with <value>;^nexample: listsplice ^"1 2 3 4 5 6^" insert 2 3" "<list> <value> <start> <count>"
setdesc "prettylist" "returns a recombined <list> with a comma placed between each list element and <conjunctor> placed between the last two elements (in addition to the comma);^nexample: prettylist ^"1 2 3 4^" and" "<list> <conjunctor>"
setdesc "shrinklist" "returns a list of all element that exists in both <list1> and <list2>;^nif there are no results and <failover> is 1 or 2, the list that failover points to is returned,^nwithout <failover>, shrinklist is equivalent to set symmetric difference;^nexample: shrinklist ^"this is a list^" ^"this is another list^", will return ^"this is list^"" "<list1> <list2> [<failover>]"
setdesc "sublist" "returns a sublist of <list> starting at <start> and ending at the end or for <count> elements;^nexample: sublist ^"this is a list^" 1 2" "<list> <start> [<count>]"
setdesc "listaverage" "returns the average of a list as an integer^nexample: do [listaverage @<list>]" "<list>"
setdesc "listaveragef" "returns the average of a list as float^nexample: do [listaveragef @<list>]" "<list>"
//logic
setdesc "&" "returns the bit-wise AND of <int1> and <int2>" "<int1> <int2>"
setdesc "&~" "returns the bit-wise NOT of the bit-wise AND of <int1> and <int2>" "<int1> <int2>"
setdesc "<<" "returns <int1> left shifted <int2> times" "<int1> <int2>"
setdesc ">>" "returns <int1> right shifted <int2> times" "<int1> <int2>"
setdesc "^^" "returns the bit-wise XOR of <int1> and <int2>" "<int1> <int2>"
setdesc "^^~" "returns the bit-wise NOT of the bit-wise XOR of <int1> and <int2>" "<int1> <int2>"
setdesc "|" "returns the bit-wise OR of <int1> and <int2>" "<int1> <int2>"
setdesc "|~" "returns the bit-wise NOT of the bit-wise OR of <int1> and <int2>" "<int1> <int2>"
setdesc "~" "returns the bit-wise NOT of <int>" "<int>"
setdesc "!" "returns the logical not of <condition>" "<condition>"
setdesc "&&" "returns the logical and of all given conditions" "<condition...>"
setdesc "?" "returns <true_body> when <condition> is true, otherwise <false_body>" "<condition> <true_body> <false_body>"
setdesc "||" "returns the logical or of all given conditions" "<condition...>"
setdesc "!=" "returns true when <int1> is not equal to <int2>" "<int1> <int2>"
setdesc "!=f" "returns true when <float1> is not equal to <float2>" "<float1> <float2>"
setdesc "!=s" "returns true when <string1> is not equal to <string2> on the ascii table" "<string1> <string2>"
setdesc "<=" "returns true when <int1> is less than or equal to <int2>" "<int1> <int2>"
setdesc "<=f" "returns true when <float1> is less than or equal to <float2>" "<float1> <float2>"
setdesc "<=s" "returns true when <string1> is less than or equal to <string2> on the ascii table" "<string1> <string2>"
setdesc "<" "returns true when <int1> is less than <int2>" "<int1> <int2>"
setdesc "<f" "returns true when <float1> is less than <float2>" "<float1> <float2>"
setdesc "<s" "returns true when <string1> is less than <string2> on the ascii table" "<string1> <string2>"
setdesc "=" "returns true when <int1> is equal to <int2>" "<int1> <int2>"
setdesc "=f" "returns true when <float1> is equal to <float2>" "<float1> <float2>"
setdesc "=s" "returns true when <string1> is equal to <string2> on the ascii table" "<string1> <string2>"
setdesc ">=" "returns true when <int1> is greater than or equal to <int2>" "<int1> <int2>"
setdesc ">=f" "returns true when <float1> is greater than or equal to <float2>" "<float1> <float2>"
setdesc ">=s" "returns true when <string1> is greater than or equal to <string2> on the ascii table" "<string1> <string2>"
setdesc ">" "returns true when <int1> is greater than <int2>" "<int1> <int2>"
setdesc ">f" "returns true when <float1> is greater than <float2>" "<float1> <float2>"
setdesc ">s" "returns true when <string1> is greater than <string2> on the ascii table" "<string1> <string2>"
setdesc "max" "returns the maximum <integer> value;^nexample: max 1 3 -9" "<integer...>"
setdesc "maxf" "returns the maximum <float> value;^nexample: maxf 1.1, 2.9, -9.5" "<float...>"
setdesc "min" "returns the minimum <integer> value;^nexample: min 1 3 -9" "<integer...>"
setdesc "minf" "returns the minimum <float> value;^nexample: minf 1.1, 2.9, -9.5" "<float...>"

setdesc "stringcasecmp" "returns true when <string1> is equal to <string2> ignoring case;^nexample: stringcasecmp ^"str^" ^"StR^"" "<string1> <string2>"
setdesc "stringcmp" "returns true when <string1> is equal to <string2>, equivalent to =s;^nexample: stringcmp ^"str^" ^"str^"" "<string1> <string2>"
setdesc "stringlen" "returns the length of <string>;^nexample: stringlen ^"four^"" "<string>"
setdesc "stringncasecmp" "returns true when the first <count> characters of <string1> and <string2> are equal ignoring case;^nexample: stringncasecmp ^"str^" ^"StRiNg^" 3" "<string1> <string2> <count>"
setdesc "stringncmp" "returns true when the first <count> characters of <string1> and <string2> are equal;^nexample: stringncmp ^"str^" ^"string^" 3" "<string1> <string2> <count>"
setdesc "stringreplace" "returns <string> with all occurrences of <search> replaced with <replace>;^nexample: stringreplace ^"misspelled sring^" ^"sring^" ^"string^"" "<string> <search> <replace>"
setdesc "stringstr" "returns the index of <search> in <string>;^nexample: stringstr ^"long string^" ^"str^"" "<string> <search>"
setdesc "substring" "returns a substringing of <string> starting at <start> and continuing to the end or for <count> characters;^nexample: substring ^"string^" 2 3" "<string> <start> [<count>]"
setdesc "concat" "returns all <value>s concatenated with a space between each argument;^nexample: concat hello (getname)" "<value...>"
setdesc "concatword" "returns all <value>s concatenated without a space between each argument;^nexample: concatword squished string" "<value...>"
setdesc "clearsleep" "removes all pending sleeps, if <clearworlds> is set, it will only clear sleeps generated in a map's config file;^nexample: clearsleep" "[<clearworlds>]"
setdesc "do" "executes <body>;^nexample: do [ echo hi ]" "<body>"
setdesc "format" "returns a formatted string with all %1 - %9 replaced with the respective <value> argument, %% inserts a % sign;^nexample: format ^"Hello, %1, welcome to Red Eclipse v. %2^" (getname) $version" "<format_string> <value...>"
setdesc "if" "execute <true_body> when <condition> is true, otherwise executes <false_body>;^nexample: if (< $var 5) [ echo less than 5 ] [ echo greater than 5 ]" "<condition> <true_body> <false_body>"
setdesc "push" "pushes <value> into <var>'s stack and executes <body> then pops <value> off of <var> so that <var> is untouched after execution of <body>;^nexample: var = 5; push var 10 [ echo $var ]; echo $var" "<var> <value> <body>"
setdesc "result" "sets the return value for the currently executing code to <value>, note that this does not stop the code execution like return would;^nexample: result 1" "<value>"
setdesc "rnd" "returns a random number between 0 or <min> and <max>;^nexample: rnd 50 25" "<max> [<min>]"
setdesc "sleep" "executes <body> after waiting <milliseconds>;^nexample: sleep 2000 [ echo waited 2 seconds ]" "<milliseconds> <body>"
setdesc "at" "returns the element at <index> in <list>, subsequent indexes are at'd with the previous result;^nexample: at [this has a [nested list]] 3 1" "<list> <index> [<nested_index>...]"
setdesc "filter" "filters a string by stripping of any or all of the following: newlines, color, and whitespace, each of these values are boolean, and true by default if omitted;^n[<newlines>] - if true, replaces newline characters with spaces,^n[<color>] - if true, any color formatting will be removed,^n[<whitespace>] - if true, whitespace is kept; if false, whitespace is removed" "<string> [<newlines>] [<color>] [<whitespace>]"
setdesc "goto" "jumps the spectator camera to the position of the specified client" "<cn>"
setdesc "hexcolour" "converts a decimal color value to a ^"pretty-printed^" hexadecimal color value;^nexample: (hexcolour 342344) will give 0x093548" "<color>"
setdesc "hexcrc" "returns a string with the 4 byte hexadecimal value of the given integer;^nexample: /echo map crc is (hexcrc $mapcrc)" "<value>"
setdesc "precf" "returns the value <float> truncated to <accuracy> number of decimals;^nexample: (precf 0.14986 2) will give 0.14" "<float> <accuracy>"
setdesc "writevars" "writes the current server's variables to a config file named <file>;^nif [<all>] is true, every variable will be written with default values commented out; if false, only changed variables will be written (default: false)^nif [<sv_>] is true, variables will be prefixed with ^"sv_^" (default: false)" "<file> [<all>] [<sv_>]"
setdesc "case"  "executes the first <body> where the corresponding <test_value> is equivalent to <integer> using integer comparison;^nfor the 'default' case (always true), use () for the <test_value>, has a limit of 12 conditions,^nexample: case (rnd 3) 0 [ echo 0 ] 1 [ echo 1 ] () [ echo default ]" "<integer> [<test_value> <body>] [<test_value> <body>] [...]"
setdesc "casef" "executes the first <body> where the corresponding <test_value> is equivalent to <float> using float comparison;^nfor the 'default' case (always true) use () for the <test_value>, has a limit of 12 conditions,^nexample: case (+f (rnd 3) .1) 0.1 [ echo 0.1 ] 1.1 [ echo 1.1 ] () [ echo default ]" "<float> [<test_value> <body>] [<test_value> <body>] [...]"
setdesc "cases" "executes the first <body> where the corresponding <test_value> is equivalent to <string> using string comparison;^nfor the 'default' case (always true) use () for the <test_value>, has a limit of 12 conditions,^nexample: case (substring ^"abc^" (rnd 3) 1) a [ echo a ] b [ echo b ] () [ echo default ]" "<string> [<test_value> <body>] [<test_value> <body>] [...]"
setdesc "cond"  "executes the first <body> where the corresponding <condition> is true, has a limit of 12 conditions;^nexample: i = (rnd 3); cond [ = $i 0 ] [ echo 0 ] [ = $i 1 ] [ echo 1 ] 1 [ echo default ]" "[<condition> <body>] [<condition> <body>] [...]"
setdesc "getvarmin" "returns the minimum value of <varname>, a built-in integer variable;^nexample: getvarmin firstpersonfov" "<varname>"
setdesc "getvarmax" "returns the maximum value of <varname>, a built-in integer variable;^nexample: getvarmax firstpersonfov" "<varname>"
setdesc "getfvarmin" "returns the minimum value of <varname>, a built-in float variable;^nexample: getfvarmin movespeed" "<varname>"
setdesc "getfvarmax" "returns the maximum value of <varname>, a built-in float variable;^nexample: getfvarmax movespeed" "<varname>"
setdesc "isonline" "returns 1 if you are online and 0 if not"
setdesc "escape" "returns a quoted string with all newline, tab, form feed, ^^, and ^" characters converted to the cubescript escape sequence (^^n, ^^t, ^^f, ^^^^, ^^^");^nexample: escape [line1^^nline2]" "<text>"
setdesc "unescape" "returns a string with all cubescript escape sequences (^^n, ^^t, ^^f, ^^^^, ^^^") converted back into newline, tab, form feed, ^^, and ^" respectively;^nexample: unescape [line1^^^^nline2]" "<text>"
//mathematic
setdesc "*" "returns all arguments multiplied together as integers" "<int...>"
setdesc "*f" "returns all arguments multiplied together as floats" "<float...>"
setdesc "+" "returns all arguments added together as integers" "<int...>"
setdesc "+f" "returns all arguments added together as floats" "<float...>"
setdesc "-" "returns all other arguments subtracted from the first argument as integers" "<int...>"
setdesc "-f" "returns all other arguments subtracted from the first argument as floats" "<float...>"
setdesc "div" "returns all other arguments divided from the first argument as integers" "<int...>"
setdesc "divf" "returns all other arguments divided from the first argument as floats" "<float...>"
setdesc "mod" "returns the modulus of <int1> and <int2> (that is, the remainder of <int1>/<int2>)" "<int1> <int2>"
setdesc "modf" "returns the modulus of <float1> and <float2> (that is, the remainder of <float1>/<float2>)" "<float1> <float2>"
setdesc "cos" "returns the cosine of <float>;^nexample: cos 3.1415" "<float>"
setdesc "sin" "returns the sine of <float>;^nexample: sin 3.1415" "<float>"
setdesc "tan" "returns the tangent of <float>;^nexample: tan 3.1415" "<float>"
setdesc "acos" "returns the arc-cosine of <float>;^nexample: acos 1" "<float>"
setdesc "asin" "returns the arc-sine of <float>;^nexample: asin 1" "<float>"
setdesc "atan" "returns the arc-tangent of <float>;^nexample: atan 1" "<float>"
setdesc "abs" "returns the absolute power of <integer>;^nexample: abs -5" "<integer>"
setdesc "absf" "returns the absolute power of <float>;^nexample: absf -8.5" "<float>"
setdesc "exp" "returns e (2.71828) raised to the <float> power;^nexample: exp 5.6" "<float>"
setdesc "pow" "returns <base> raised to the power of <exponent>;^nexample: pow 2.1 8.1" "<base> <exponent>"
setdesc "sqrt" "returns the square root of <float>;^nexample: sqrt 4" "<float>"
setdesc "log10" "return the logarithm of <float> with base 10;^nexample: log10 1000" "<float>"
setdesc "log2" "return the logarithm of <float> with base 2;^nexample: log2 8" "<float>"
setdesc "loge" "return the logarithm of <float> with base e;^nexample: loge 20.08" "<float>"

setdesc "sortlist" "returns a sorted list (quicksort) based on the result of <body> applied onto <list>;^n if <body> returns true the two elements <varname_1> and <varname_2> will be swapped, unchanged otherwise,^nexample: sortlist ^"cat ape bear boar^" a b [<s $a $b], will return ^"ape bear boar cat^" (<s is ascii-alphabetic comparison)" "<list> <varname_1> <varname_2> <body>"
setdesc "stripcolors" "returns the <string> without any colors;^nexample: stripcolors ^"^^frhello ^^f[6252287]^"" "<string>"
setdesc "addlocalop" "elevates the privilege of a user to a specified level locally;^nthis allows server administrators to ^"upgrade^" the access of people as they identify, on that particular server,^n<user_handle> is the authkey handle of the user,^n<flag> is the privilege level {a = administrator m = moderator o = operator s = supporter}" "<user_handle> <flag>"
setdesc "resetlocalop" "removes all temporary elevated local privileges;^nthis allows server administrators to reset the access given by addlocalop for all users, on that particular server"
setdesc "ircaddchan" "joins a channel on a given IRC instance with automatic rejoin;^n<name> - name of the IRC instance,^n<channel> - channel to join,^n[<friendly>] - optional friendly name of <channel>,^n[<passkey>] - optional passkey required for mode +k channels,^n[<relay>] - optional relay level (verbosity of output)" "<name> <channel> [<friendly>] [<passkey>] [<relay>]"
setdesc "ircaddclient" "creates an IRC instance of type 'client';^n<name> - name of the created IRC instance,^n<host> - host to connect to,^n<port> - port of <host> to connect on,^n<nick> - nickname to use for the connection,^n[<ip>] - optional address to bind to (leave blank for any),^n[<passkey>] - optional password required to connect to <host>" "<name> <host> <port> <nick> [<ip>] [<passkey>]"
setdesc "ircaddrelay" "creates an IRC instance of type 'relay';^n<name> - name of the created IRC instance,^n<host> - host to connect to,^n<port> - port of <host> to connect on,^n<nick> - nickname to use for the connection,^n[<ip>] - optional address to bind to (leave blank for any),^n[passkey] - optional password required to connect to <host>" "<name> <host> <port> <nick> [<ip>] [<passkey>]"
setdesc "ircjoinchan" "joins a channel on a given IRC instance without automatic rejoin;^n<name> - name of the IRC instance,^n<channel> - channel to join,^n[<friendly>] - optional friendly name of <channel>,^n[<passkey>] - optional passkey required for mode +k channels^n[<relay>] - optional relay level (verbosity of output)" "<name> <channel> [<friendly>] [<passkey>] [<relay>]"
setdesc "ircfilter" "sets how IRC messages are filtered;^n0 = send string as is, color escapes not converted, other escapes not filtered,^n1 = convert Cube2-style color escapes to IRC color escapes,^n2 = filter out all Cube2-style escapes" "<value>"
setdesc "ircbind" "sets the address that an IRC instance binds to;^nwhen used without [<ip>], returns the address that the IRC instance '<name>' is currently bound to,^n<name> - name of the IRC instance,^n[<ip>] - optional ip address for <name> to bind to" "<name> [<ip>]"
setdesc "ircconnect" "attempts to establish a connection to the IRC instance '<name>'" "<name>"
setdesc "ircconns" "returns the number of active IRC connections"
setdesc "ircfriendlychan" "sets the friendly name of an IRC channel;^nif the [<friendly>] parameter is not specified, the current friendly name of the channel is returned,^n<name> - name of an IRC instance,^n<channel> - the IRC channel,^n[<friendly>] - optional new friendly name to use" "<name> <channel> [<friendly>]"
setdesc "ircnick" "sets the nickname of an IRC instance;^nif the [<nick>] parameter is not specified, the current nickname is returned,^n<name> - name of the IRC instance,^n[<nick>] - optional new nickname" "<name> [<nick>]"
setdesc "ircpass" "sets the server passkey used by an IRC instance;^nif the [<passkey>] parameter is not specified, ^"<set>^" or ^"<not set>^" will be returned accordingly,^n<name> - name of the IRC instance,^n[<passkey>] - optional new passkey" "<name> [<passkey>]"
setdesc "ircpasschan" "sets the passkey for a channel on an IRC instance;^nif the [<passkey>] parameter is not specified, ^"<set>^" or ^"<not set>^" will be returned accordingly,^n<name> - name of the IRC instance^n<channel> - the IRC channel,^n[<passkey>] - optional new passkey" "<name> [<passkey>]"
setdesc "ircrelaychan" "sets the relay level for a channel on an IRC instance;^nif the [<relay>] parameter is not specified, the current relay level will be returned,^n<name> - name of the IRC instance,^n<channel> - the IRC channel,^n[<relay>] - optional new relay level (verbosity of output)" "<name> <channel> [<relay>]"
setdesc "ircport" "sets the server port used by an IRC instance;^nif the [<port>] parameter is not specified, the current server port is returned,^n<name> - name of an IRC instance,^n[<port>] - optional new port" "<name> [<port>]"
setdesc "ircserv" "sets the host to connect to for a given IRC instance;^nif the [<host>] parameter is not specified, the current host is returned,^n<name> - name of an IRC instance,^n[<host>] - optional new hostname" "<name> [<host>]"
setdesc "ircauth" "sends a message to a specified target when succefully connected to an an IRC server;^ncan be used for setting up automatic authentication,^nif only <name> is specified, [<target>] is returned along with ^"<set>^" or ^"<not set>^" for [<message>],^n<name> - name of the IRC instance,^n[<target>] - target for the message (user, service, channel),^n[<message>] - message sent to [<target>],^nexample: ircauth myrelay NickServ ^"IDENTIFY password^"" "<name> [<target>] [<message>]"
setdesc "botoffset" "increases or decreases the amount of bots starting from the numplayers value of the current map" "<value>"
setdesc "mapcomplete" "enables map completion for a given command or alias;^nthis enables tab-completion for the first argument of an already existing command or alias,^nthe completion uses files that ends with 'mpz' in the 'maps' folders of the game's homedir, and its data dir(s)" "<command>"
setdesc "map" "requests a map change to a given map, with no change of mode or mutators;^ndepending on privileges, this will force or vote for the map change" "<map>"
//modes
setdesc "gamemode" "returns the current game mode; 0 = demo, 1 = edit, 2 = dm, 3 = ctf, 4 = dac, 5 = bb, 6 = race"
setdesc "mode" "sets the mode and mutator values for the next map change request;^n<mode> sets the mode type,^n<muts> sets the mutators according to a bitwise sum of mutator values,^nconveniently set using $modeidx* vars and sums of $mutsbit* vars,^nexample: mode $modeidxdeathmatch (+ $mutsbitinstagib $mutsbitmedieval)" "<mode> <muts>"
setdesc "start" "requests a map change to a given map with a specific mode and mutators;^ndepending on privileges, this will force or vote for the map change,^n<mode> sets the mode type,^n<muts> sets the mutators according to a bitwise sum of mutator values,^nconveniently set using $modeidx* vars and sums of $mutsbit* vars,^nexample: start bath $modeidxdeathmatch (+ $mutsbitinstagib $mutsbitmedieval)" "<map> <mode> <muts>"
setdesc "edit" "starts editing on a new map file named ^"mapname.mpz^" or loads mapname.mpz if it already exists" "<map>"
setdesc "demo" "starts playback of a given demo" "<demo>"
setdesc "deathmatch" "requests a map change to deathmatch on a given map;^n[<muts>] optionally adds extra mutators according to bitwise mutator values, conveniently set using a sum of $mutsbit* vars,^nexample: deathmatch bath (+ $mutsbitinstagib $mutsbitmedieval)" "<map> [<muts>]"
setdesc "dm" "requests a map change to deathmatch on a given map;^n[<muts>] optionally adds extra mutators according to bitwise mutator values, conveniently set using a sum of $mutsbit* vars,^nexample: dm bath (+ $mutsbitinstagib $mutsbitmedieval)" "<map> [<muts>]"
setdesc "teamdm" "requests a map change to team deathmatch on a given map;^n[<muts>] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: teamdm bath (+ $mutsbitinstagib $mutsbitmedieval)" "<map> [<muts>]"
setdesc "tdm" "requests a map change to team deathmatch on a given map;^n[<muts>] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: tdm bath (+ $mutsbitinstagib $mutsbitmedieval)" "<map> [<muts>]"
setdesc "multidm" "requests a map change to multi deathmatch on a given map;^n[<muts>] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: multidm bath (+ $mutsbitinstagib $mutsbitmedieval)" "<map> [<muts>]"
setdesc "mdm" "requests a map change to multi deathmatch on a given map;^n[<muts>] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: mdm bath (+ $mutsbitinstagib $mutsbitmedieval)" "<map> [<muts>]"
setdesc "coop" "requests a map change to coop deathmatch on a given map;^n[<muts>] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: coop bath (+ $mutsbitinstagib $mutsbitmedieval)" "<map> [<muts>]"
setdesc "cdm" "requests a map change to coop deathmatch on a given map;^n[<muts>] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: cdm bath (+ $mutsbitinstagib $mutsbitmedieval)" "<map> [<muts>]"
setdesc "instagib" "requests a map change to instagib deathmatch on a given map;^n[<muts>] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: instagib bath (+ $mutsbitduel $mutsbitmedieval)" "<map> [<muts>]"
setdesc "insta" "requests a map change to instagib deathmatch on a given map;^n[<muts>] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: insta bath (+ $mutsbitduel $mutsbitmedieval)" "<map> [<muts>]"
setdesc "medieval" "requests a map change to medieval deathmatch on a given map;^n[<muts>] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: medieval bath (+ $mutsbitinstagib $mutsbitfreestyle)" "<map> [<muts>]"
setdesc "kaboom" "requests a map change to kaboom deathmatch on a given map;^n[<muts>] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: kaboom bath (+ $mutsbitinstagib $mutsbitfreestyle)" "<map> [<muts>]"
setdesc "duel" "requests a map change to duel deathmatch on a given map;^n[<muts>] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: duel bath (+ $mutsbitinstagib $mutsbitmedieval)" "<map> [<muts>]"
setdesc "survivor" "requests a map change to survivor deathmatch on a given map;^n[<muts>] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: survivor bath (+ $mutsbitinstagib $mutsbitmedieval)" "<map> [<muts>]"
setdesc "lms" "requests a map change to survivor deathmatch (last man standing) on a given map;^n[<muts>] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: lms bath (+ $mutsbitinstagib $mutsbitmedieval)" "<map> [<muts>]"
setdesc "classic" "requests a map change to classic deathmatch on a given map;^n[<muts>] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: classic bath (+ $mutsbitinstagib $mutsbitduel)" "<map> [<muts>]"
setdesc "capture" "requests a map change to capture-the-flag on a given map;^n[<muts>] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: capture bath (+ $mutsbitinstagib $mutsbitmedieval)" "<map> [<muts>]"
setdesc "ctf" "requests a map change to capture-the-flag on a given map;^n[<muts>] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: ctf bath (+ $mutsbitinstagib $mutsbitmedieval)" "<map> [<muts>]"
setdesc "quickcapture" "requests a map change to quick capture-the-flag on a given map;^n[<muts>] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: quickcapture bath (+ $mutsbitinstagib $mutsbitmedieval)" "<map> [<muts>]"
setdesc "defendcapture" "requests a map change to defend capture-the-flag on a given map;^n[<muts>] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: defendcapture bath (+ $mutsbitinstagib $mutsbitmedieval)" "<map> [<muts>]"
setdesc "protectcapture" "requests a map change to protect capture-the-flag on a given map;^n[<muts>] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: protectcapture bath (+ $mutsbitinstagib $mutsbitmedieval)" "<map> [<muts>]"
setdesc "defend" "requests a map change to defend-and-control on a given map;^n[<muts>] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: defend bath (+ $mutsbitinstagib $mutsbitmedieval)" "<map> [<muts>]"
setdesc "dac" "requests a map change to defend-and-control on a given map;^n[<muts>] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: dac bath (+ $mutsbitinstagib $mutsbitmedieval)" "<map> [<muts>]"
setdesc "dnc" "requests a map change to defend-and-control on a given map;^n[<muts>] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: dac bath (+ $mutsbitinstagib $mutsbitmedieval)" "<map> [<muts>]"
setdesc "quickdefend" "requests a map change to quick defend-and-control on a given map;^n[<muts>] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: quickdefend bath (+ $mutsbitinstagib $mutsbitmedieval)" "<map> [<muts>]"
setdesc "kingdefend" "requests a map change to king defend-and-control on a given map;^n[<muts>] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: kingdefend bath (+ $mutsbitinstagib $mutsbitmedieval)" "<map> [<muts>]"
setdesc "koth" "requests a map change to king defend-and-control (king of the hill) on a given map;^n[<muts>] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: koth bath (+ $mutsbitinstagib $mutsbitmedieval)" "<map> [<muts>]"
setdesc "bomber" "requests a map change to bomber-ball on a given map;^n[<muts>] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: bomber futuresport (+ $mutsbitinstagib $mutsbitmedieval)" "<map> [<muts>]"
setdesc "bb" "requests a map change to bomber-ball on a given map;^n[<muts>] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: bb futuresport (+ $mutsbitinstagib $mutsbitmedieval)" "<map> [<muts>]"
setdesc "holdbomber" "requests a map change to hold bomber-ball on a given map;^n[<muts>] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: holdbomber bath (+ $mutsbitinstagib $mutsbitmedieval)" "<map> [<muts>]"
setdesc "basketbomber" "requests a map change to basket bomber-ball on a given map;^n[<muts>] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: basketbomber bath (+ $mutsbitinstagib $mutsbitmedieval)" "<map> [<muts>]"
setdesc "attackbomber" "requests a map change to attack bomber-ball on a given map;^n[<muts>] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: attackbomber bath (+ $mutsbitinstagib $mutsbitmedieval)" "<map> [<muts>]"
setdesc "race" "requests a map change to race on a given map;^n[<muts>] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: race purge (+ $mutsbitfreestyle $mutsbitmedieval)" "<map> [<muts>]"
setdesc "timedrace" "requests a map change to timed race on a given map;^n[<muts>] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: timedrace purge (+ $mutsbitffa $mutsbitfreestyle)" "<map> [<muts>]"
setdesc "trial" "requests a map change to timed race on a given map;^n[<muts>] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: trial purge (+ $mutsbitffa $mutsbitfreestyle)" "<map> [<muts>]"
setdesc "endurancerace" "requests a map change to endurance race on a given map;^n[<muts>] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: endurancerace purge (+ $mutsbitffa $mutsbitfreestyle)" "<map> [<muts>]"
setdesc "gauntletrace" "requests a map change to gauntlet race on a given map;^n[<muts>] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: gauntletrace purge (+ $mutsbitffa $mutsbitfreestyle)" "<map> [<muts>]"

setdesc "writevarsinfo" "writes raw information about all existing vars, commands and aliases to a file;^nfor each item the following fields are printed: NAME TYPE FLAGS ARGS VALTYPE VALUE MIN MAX DESC USAGE,^nfields are separated by tabs, and empty if nonexistent" "<file>"
setdesc "simpleitems" "sets how items are shown in the level;^n0 = items are models, 1 = items are icons, 2 = items are off and only halos appear" "<level>"
setdesc "simpleitemsize" "sets the size of simple items" "<size>"
setdesc "simpleitemblend" "sets the blend level of simple items" "<blend>"
setdesc "simpleitemhalo" "adjusts the halo blend when displaying simple items as icon" "<blend>"
setdesc "autospecdelay" "determines the delay after player joins spectators after being fragged" "<milliseconds>"
setdesc "bomberlockondelay" "determines the amount of time needed to hold throw button to achieve assisted pass to another team member" "<milliseconds>"
setdesc "capturecarryspeed" "multiplier for the movement speed of flag-carrying players;^nacts as an added multiplier on top of the normal movespeed multiplier" "<value>"
setdesc "capturepickupdelay" "time a player needs to wait to be able to pick up a flag again after losing it" "<milliseconds>"
setdesc "coopskillmax" "determines the maximum skill level a bot can have in coop" "<skill level>"
setdesc "coopskillmin" "determines the minimum skill level a bot can have in coop" "<skill level>"
setdesc "fragbonus" "determines the amount of points a player gets for each frag" "<value>"
setdesc "enemybonus" "determines the amount of points a player gets for frags against neutral enemies in onslaught" "<value>"
setdesc "headshotpoints" "determines the amount of bonus points a player gets when a frag is caused by a headshot" "<value>"
setdesc "multikillpoints" "determines the amount of bonus points a player gets for a double, triple, or multi kill" "<value>"
setdesc "multikillbonus" "determines if multikillpoints should be multiplied by 2, 3, or 4 as appropriate" "<value>"
setdesc "spreepoints" "determines the amount of points a player gets for achieving each level of killing spree for the first time" "<value>"
setdesc "spreebreaker" "determines the amount of points a player gets for ending an opponent's killing spree" "<value>"
setdesc "dominatepoints" "determines the amount of points a player gets when he achieves domination on another player" "<value>"
setdesc "revengepoints" "determines the amount of points a player gets when he gets revenge against a dominating player" "<value>"
setdesc "firstbloodpoints" "determines the amount of points a player gets when he makes the first kill of a match" "<value>"
setdesc "mapbalance" "determines if teams are switched on asymmetrical maps after half of the time is over;^n0 = no balance, 1 = balance only in ctf/dac/bb, 2 = balance in all modes" "<value>"
setdesc "teamkillban" "automatically ban player when warned this many times for teamkill" "<value>"
setdesc "teamkillkick" "automatically kick player when warned this many times for teamkill" "<value>"
setdesc "teamkillpenalty" "subtract this*fragbonus from the players points when teamkilling" "<value>"
setdesc "teamkillrestore" "restore the team score as if the teamkiller was never there if the point loss of the team was greater than this" "<value>"
setdesc "teamkilltime" "time threshold in which teamkills are counted" "<minutes>"
setdesc "teamkillwarn" "the limit of teamkills after which the player receives a warning" "<value>"
setdesc "waitforplayers" "wait this long for players to load the map" "<milliseconds>"
setdesc "waitforplayerannounce" "update everyone on the progress every this often" "<milliseconds>"
//talking
setdesc "saycommand" "write a chat message or command but waits for your affirmation to send it" "<text>"
setdesc "say" "send a message to the global chat" "<text>"
setdesc "me" "send a message to the global chat in the form of an action^nex: * foobar demonstrates something" "<text>"
setdesc "sayteam" "send a message to the team chat" "<text>"
setdesc "meteam" "send a message to the team chat in the form of an action^nex: * foobar (to team ...) demonstrates something" "<text>"
setdesc "whisper" "send a message directly to another player on the server^n^frnote: messages are ^fRnot ^frprivate and are visible in demos" "<cn> <text>"
setdesc "mewhisper" "send a message directly to another player on the server in the form of an action^nex: * foobar (whispers to barfoo) demonstrates something^n^frnote: messages are ^fRnot ^frprivate and are visible in demos" "<cn> <text>"

//weapons
looplist w $weapname [
    setdesc (concatword $w ammoadd) "the amount added when picking up the weapon or reloading it" "<value>"
    setdesc (concatword $w ammomax) "the maximum amount the clip of this weapon can hold, can never be higher than default" "<value>"
    setdesc (concatword $w delayreload) "the time it takes for the weapon to reload one 'add' unit" "<milliseconds>"
    setdesc (concatword $w laser) "determines if this weapon has a laser pointer which is projected to the point where the player is aiming" "<value>"
    setdesc (concatword $w frequency) "determines the multiplier of itemspawntime in which items of this type respawn in" "<value>"
    setdesc (concatword $w colour) "determines the weapon main colour;^naffects the light around the weapon, the ammo and the icon in the weaponlist" "<colour>"
    setdesc (concatword $w modes) "determines the modes in which this weapon is allowed or disallowed;^nconveniently set as a sum of $modebit* vars,^npositive sum: allow this weapon if one of the declared modes is selected,^nnegative sum: disallow this weapon if one if the declared modes is selected" "<sum>"
    setdesc (concatword $w muts) "determines the mutators in which this weapon is allowed or disallowed;^nconveniently set as a sum of $mutsbit* vars,^npositive sum: allow this weapon if one of the declared mutators is selected,^nnegative sum: disallow this weapon if one of the declared mutators is selected" "<sum>"

    loop n 2 [
        m = (+ $n 1)
        setdesc (concatword $w ammosub $m) "the amount taken from the clip for each firing action, set to zero for unlimited ammo" "<value>"
        setdesc (concatword $w delayattack $m) "the time it takes after each firing action for the weapon to be ready again" "<milliseconds>"
        setdesc (concatword $w damage $m) "the amount of damage a projectile from each firing action does" "<value>"
        setdesc (concatword $w speed $m) "the speed of a projectile from each firing action" "<value>"
        setdesc (concatword $w cooktime $m) "when more than zero, determines that the weapon can be 'cooked' this long before firing" "<value>"
        setdesc (concatword $w time $m) "the maximum lifetime of a projectile for each firing action" "<milliseconds>"
        setdesc (concatword $w projdelay $m) "when more than zero, projectiles from this weapon will be delayed this long" "<milliseconds>"
        setdesc (concatword $w guideddelay $m) "when more than zero, projectiles from this weapon will delay guided settings by this long" "<milliseconds>"
        setdesc (concatword $w escapedelay $m) "when more than zero, projectiles from this weapon will not be able to hurt its owner for this long" "<milliseconds>"
        setdesc (concatword $w explode $m) "determines the explosion radius for a particle of this firing action" "<value>"
        setdesc (concatword $w rays $m) "the amount of projectiles spawned from one shot of each firing action" "<value>"
        setdesc (concatword $w spread $m) "determines the amount a projectile from each firing action skews off-center" "<value>"
        setdesc (concatword $w spreadz $m) "when zero, keeps spread projectiles aligned horizontally, else divide the z axis this much" "<value>"
        setdesc (concatword $w aiskew $m) "determines 'added stupidity' for each weapon for AI counterparts" "<value>"
        setdesc (concatword $w fragweap $m) "when projectiles from this firing action are destroyed, create projectiles from this kind of weapon (+12 = alt fire for the weapon)" "<value>"
        setdesc (concatword $w flakdamage $m) "flak of this type deals this much damage" "<value>"
        setdesc (concatword $w fragrays $m) "when creating flak, create this many projectiles for it" "<value>"
        setdesc (concatword $w fragtime $m) "flak projectiles from this weapon last this long" "<milliseconds>"
        setdesc (concatword $w fragspeed $m) "flak projectiles from this weapon start with this much speed (may be influenced by fragspread/fragskew and fragrel)" "<value>"
        setdesc (concatword $w collide $m) "determines collision properties for a projectile from each firing action (bitwise OR);^nCOLLIDE_TRACE = 1, COLLIDE_PROJ = 2, COLLIDE_OWNER = 4, IMPACT_GEOM = 8, IMPACT_PLAYER = 16, IMPACT_SHOTS = 32, BOUNCE_GEOM = 64, BOUNCE_PLAYER = 128, BOUNCE_SHOTS = 256, DRILL_GEOM = 512, DRILL_PLAYER = 1024, DRILL_SHOTS = 2048, STICK_GEOM = 4096, STICK_PLAYER = 8192" "<sum>"
        setdesc (concatword $w extinguish $m) "determines if a projectile from each firing action is extinguished by water" "<value>"
        setdesc (concatword $w cooked $m) "determines cooking style for a projectile, &1 = more damage, &2 = less damage, &4 = longer lifetime, &8 = shorter lifetime, &16 = faster speed, &32 = slower speed, &64 = extra rays, &128 = zoom view" "<value>"
        setdesc (concatword $w guided $m) "determines guided style for a projectile, 0 = off, 1 = follow crosshair direction, 2 = home crosshair target (+1 only first target), 4 = home projectile target (+1 only first target), 6 = direct toward first crosshair direction" "<value>"
        setdesc (concatword $w radial $m) "determines the time between ticks of ^"continuous^" radial damage, starts counting from first ^"radiation^"" "<milliseconds>"

        setdesc (concatword $w residual $m) "determines if a projectile from each firing action has a residual effect;^n0 = off, 1 = burns, 2 = bleeds, 4 = shocks" "<bits>"
        setdesc (concatword $w residualundo $m) "determines if a projectile from each firing action will extinguish a residual effect;^n0 = off, 1 = burns, 2 = bleeds, 4 = shocks" "<bits>"
        setdesc (concatword $w fullauto $m) "determines if each firing action is fully automatic (click-and-hold) or not (click-and-click)" "<bool>"
        setdesc (concatword $w taperin $m) "determines the fraction of the lifetime from the start until the projectile reaches its full size" "<value>"
        setdesc (concatword $w taperout $m) "determines the fraction of the lifetime from the end where the projectile size ^"fades out^"" "<value>"
        setdesc (concatword $w elasticity $m) "multiplier of velocity for a projectile of each firing action when doing a bounce event" "<value>"
        setdesc (concatword $w reflectivity $m) "guard angle for a projectile of each firing action when doing a bounce event" "<angle>"
        setdesc (concatword $w relativity $m) "multiplier of player velocity added to a projectile of each firing action" "<value>"
        setdesc (concatword $w liquidcoast $m) "multiplier of velocity for a projectile of each firing action when in liquid" "<value>"
        setdesc (concatword $w weight $m) "relative weight for a projectile of each firing action" "<value>"
        setdesc (concatword $w radius $m) "determines the size for a projectile of each firing action" "<value>"
        setdesc (concatword $w kickpush $m) "determines the amount of pushback from shooting each firing action" "<value>"
        setdesc (concatword $w hitpush $m) "determines the amount of pushback from getting hit by this shot" "<value>"
        setdesc (concatword $w aidist $m) "determines the 'maximum distance' a weapon should be shot at, used by AI to determine weapon effectiveness ranges" "<distance>"
        setdesc (concatword $w partsize $m) "determines the maximum particle size of a projectile from each firing action" "<value>"
        setdesc (concatword $w partlen $m) "determines the maximum tape particle length of a projectile from each firing action" "<value>"
        setdesc (concatword $w delta $m) "determines the amount by which each firing action is guided" "<value>"
        setdesc (concatword $w trace $m) "determines the multiplier of length to apply to traced weapons" "<value>"
        setdesc (concatword $w damagetorso $m) "determines the multiplier of damage for torso shots" "<value>"
        setdesc (concatword $w damagelegs $m) "determines the multiplier of damage for leg shots" "<value>"
        setdesc (concatword $w damagehead $m) "determines the multiplier of damage for head shots" "<value>"
        setdesc (concatword $w fragscale $m) "flak created by this firing action is scaled by this much" "<value>"
        setdesc (concatword $w fragspread $m) "flak created by this firing action spreads its direction randomly by this much if it doesn't impact a player" "<value>"
        setdesc (concatword $w fragrel $m) "flak created by this firing action retains this much of its parent relative momentum" "<value>"
        setdesc (concatword $w fragoffset $m) "flak created by this firing action is offset by this distance if it impacts a player before being created" "<value>"
        setdesc (concatword $w fragskew $m) "flak created by this firing action spreads its direction randomly by this much when it impacts a player" "<value>"
        setdesc (concatword $w wavepush $m) "determines the multiplier of explode radius this weapon pushes in" "<value>"
        setdesc (concatword $w explcol $m) "determines the colour of the explosion of a projectile from this weapon" "<colour>"
        setdesc (concatword $w flakcollide $m) "determines collision properties for flak of this type from each firing action (bitwise OR);^nIMPACT_GEOM = 1, BOUNCE_GEOM = 2, IMPACT_PLAYER = 4, BOUNCE_PLAYER = 8, RADIAL_PLAYER = 16, COLLIDE_TRACE = 32, COLLIDE_OWNER = 64, COLLIDE_CONT = 128, COLLIDE_STICK = 256" "<sum>"
        setdesc (concatword $w flakexplcol $m) "determines the colour of the explosion of flak of this type" "<colour>"
        setdesc (concatword $w flakpartcol $m) "determines the colour of flak of this type" "<colour>"
        setdesc (concatword $w flakresidual $m) "determines the residual effects for flak of this type from each firing action (bitwise OR);^n0 = off, 1 = burns, 2 = bleeds, 4 = shocks" "<sum>"
        setdesc (concatword $w partcol $m) "determines the colour of a projectile from this weapon" "<colour>"
        setdesc (concatword $w parttype $m) "determines the type of projectiles this weapon shoots" "<value>"
        setdesc (concatword $w residual $m) "determines the residual effects of a projectile from each firing action (bitwise OR);^n0 = off, 1 = burns, 2 = bleeds, 4 = shocks" "<sum>"
    ]
]
