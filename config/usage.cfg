// sets descriptions for commands, variables and aliases
// usage: setdesc name description fields
// fields are keywords to describe either
//      the bits of a bitfield variable
//      or the arguments of a command
setdesc "kick" "kicks a player from the server with an optional reason" "name/cn [text]"
setdesc "allow" "sets a ban exemption for a player on the server" "name/cn"
setdesc "ban" "bans a player from the server with an optional reason" "name/cn [text]"
setdesc "mute" "mutes a player on the server with an optional reason" "name/cn [text]"
setdesc "limit" "limits team changing for a player on the server" "name/cn"
setdesc "spectator" "put a player to spectator mode;^n0 = join/unquarantine, 1 = spectate, 2 = spectate and quarantine" "name/cn mode"
setdesc "addpriv" "adds local priv to cn;^npriv: 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator" "name/cn priv"
setdesc "resetpriv" "removes privileges added by addpriv from cn" "name/cn"
setdesc "quit" "quits the game"
setdesc "connect" "connect to a multiplayer server" "[IP or hostname port admin or server password]"
setdesc "version" "game version for scripts" "version"
setdesc "servertype" "type of server, 1 = private (does not register with masterserver), 2 = public, 3 = dedicated" "value"
setdesc "hasoctapaks" "mega hack;^ntry to find Cube 2, done after our own data so as to not clobber stuff" "value"
setdesc "autosavebackups" "make backups;^n0 = off, 1 = single backup, 2 = named backup, 3/4 = same as 1/2 with move to ^"backups/^"" "value"
setdesc "autoreloading" "0 = never, 1 = when empty, 2 = weapons that don't add a full clip, 3 = always (+1 zooming weaps too)" "value"
setdesc "skipspawnweapon" "skip spawnweapon;^n0 = never, 1 = if numweaps gt 1 (+1), 3 = if carry gt 0 (+2), 6 = always" "value"
setdesc "skipclaw" "skip claw;^n0 = never, 1 = if numweaps gt 1 (+2), 4 = if carry gt 0 (+2), 7 = if carry gt 0 and is offset (+2), 10 = always" "value"
setdesc "skippistol" "skip pistol;^n0 = never, 1 = if numweaps gt 1 (+2), 4 = if carry gt 0 (+2), 7 = if carry gt 0 and is offset (+2), 10 = always" "value"
setdesc "skipgrenade" "skip grenade;^n0 = never, 1 = if numweaps gt 1 (+2), 4 = if carry gt 0 (+2), 7 = if carry gt 0 and is offset (+2), 10 = always" "value"
setdesc "skiprocket" "skip rocket;^n0 = never, 1 = if numweaps gt 1 (+2), 4 = if carry gt 0 (+2), 7 = if carry gt 0 and is offset (+2), 10 = always" "value"
setdesc "skippickup" "disallow pickups for skipped weapons" "value"
setdesc "weapselectslot" "determines how weapons are selected using the number keys;^n0 = by global weapon numbers, 1 = by temporary pickup slot numbers" "bool"
setdesc "showaiinfo" "determines how much info is shown for bots;^n0 = hide bot info, 1 = show bot joins/parts, 2 = show more verbose info" "value"
setdesc "demoautoclientsave" "determines if the client automatically saves demos after each match" "value"
setdesc "demolock" "determines who may record demos;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder" "value"
setdesc "democount" "determines the maximum amount of demo files that may be saved simultaneously on the server (deletes old demos if exceeded)" "value"
setdesc "demomaxsize" "determines the maximum size of individual demo files that may be saved on the server" "bytes"
setdesc "demoautorec" "determines if demos are automatically recorded each match" "value"
setdesc "demoautoserversave" "determines if the server automatically saves demos to disk" "value"
setdesc "demoserverkeeptime" "if greater than 0, only keep auto-recorded demos younger than demoserverkeeptime seconds" "value"
setdesc "listdemos" "get a list of recorded demos available for download" ""
setdesc "getdemo" "get the demo id and save to the name name, id defaults to the last and name defaults to the current time" "[id] [name]"
setdesc "mastermode" "set a specific mode to the server;^n0 = open (everybody can join), 1 = veto (vetolock determines who can force a vote), 2 = locked (only moderator or higher can spawn), 3 = private (only global privs and players with the password can join the server)" "value"
setdesc "masterlock" "determines who can set mastermode;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "value"
setdesc "spawneditlock" "determines who may spawn during editing when mastermode = 2 (lock), but not make changes to the map;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "value"
setdesc "editlock" "determines who may spawn during editing when mastermode = 2 (lock);^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "value"
setdesc "speclock" "determines who may force players to spectate;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "value"
setdesc "crclock" "determines who may use maps with an incorrect CRC integrity check;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "value"
setdesc "kicklock" "determines who may kick players;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "value"
setdesc "allowlock" "determines who may allow players;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "value"
setdesc "banlock" "determines who may ban players;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "value"
setdesc "mutelock" "determines who may mute players;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "value"
setdesc "limitlock" "determines who may limit players;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "value"
setdesc "vetolock" "determines who may force match votes;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "value"
setdesc "floodlock" "enables flood protection for everyone below a specific privilege level;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "value"
setdesc "floodmute" "automatically mute player when warned this many times" "value"
setdesc "floodtime" "time span to check for floody messages" "value"
setdesc "floodlines" "number of lines in floodtime span before too many" "value"
setdesc "autospectate" "determines when the game switches automatically to spectate mode;^n0 = when idle, 1 = when remaining dead for autospecdelay" "bool"
setdesc "resetallowsonend" "determines when the allow list is reset;^n0 = off, 1 = just when empty, 2 = when matches end" "value"
setdesc "resetbansonend" "determines when the ban list is reset;^n0 = off, 1 = just when empty, 2 = when matches end" "value"
setdesc "resetmutesonend" "determines when the mute list is reset;^n0 = off, 1 = just when empty, 2 = when matches end" "value"
setdesc "resetlimitsonend" "determines when the limit list is reset;^n0 = off, 1 = just when empty, 2 = when matches end" "value"
setdesc "resetvarsonend" "determines when these game variables are reset;^n0 = off, 1 = just when empty, 2 = when matches end" "value"
setdesc "resetmmonend" "determines when privilege mode changes are reset;^n0 = off, 1 = just when empty, 2 = when matches end" "value"
setdesc "gamespeedlock" "determines if gamespeed is locked (also limited by varslock);^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "value"
setdesc "rotatemodefilter" "determines the modes which can be selected when the server selects the next map,^nconvenient to set using a sum of $modebit* vars, for example: (+ $modebitediting $modebitdeathmatch)" $modeidxname
setdesc "rotatemuts" "determines if mutators rotate when the server selects the next map;^n0 = never rotate mutators, 1 = always rotate mutators, >1 = decrease chances the larger this value" "value"
setdesc "rotatemutsfilter" "determines the mutators which can be picked when the server selects the next map,^nconvenient to set using a sum of $mutsbit* vars" (concat $mutsidxname mode-specific1 mode-specific2 mode-specific3)"
setdesc "kingmaps" "king-of-the-hill maps" "list"
setdesc "multimaps" "maps allowed for modes which *require* multi spawns (ctf/bb)" "list"
setdesc "modelock" "determines at which privilege level modes are locked, according to modelocktype;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "value"
setdesc "modelocktype" "determines the mode locking type;^n0 = off, 1 = lock level only, 2 = lock level can set limited mode and higher" "value"
setdesc "mapsfilter" "0 = off, 1 = filter based on mutators, 2 = also filter based on players" "value"
setdesc "mapslock" "determines at which privilege level maps are locked, according to mapslocktype;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "value"
setdesc "mapslocktype" "determines the maps locking type;^n0 = off, 1 = lock level only, 2 = lock level can select non-rotation" "value"
setdesc "varslock" "determines if vars are locked;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "value"
setdesc "votelock" "determines at which privilege level votes are locked, according to votelocktype;^n0 = off, 1 = player, 2 = supporter, 3 = moderator, 4 = operator, 5 = administrator, 6 = developer, 7 = founder, 8 = nobody" "value"
setdesc "votelocktype" "determines the vote locking type;^n0 = off, 1 = lock level only, 2 = lock level can select prevmaps" "value"
setdesc "votewait" "time in milliseconds before a player may cast another vote (to avoid flooding)" "milliseconds"
setdesc "votestyle" "determines how mid-match votes are handled;^n0 = votes don't pass mid-match, 1 = passes if votethreshold is met, 2 = passes if unanimous" "milliseconds"
setdesc "votethreshold" "auto-pass votes when this many agree" "value"
setdesc "voteinterm" "0 = must wait entire time, 1 = passes if votethreshold is met, 2 = passes if unanimous" "value"
setdesc "votefilter" "filters out spectators that have not voted from the threshold" "value"
setdesc "smallmapmax" "maximum number of players for a small map" "value"
setdesc "mediummapmax" "maximum number of players for a medium map" "value"
setdesc "maxalive" "only allow this*numplayers (for current map) to be alive at once" "value"
setdesc "maxalivequeue" "toggle queue system (used if number of players exceeds maxalive*numplayers for current map);^n0 = prohibits leaving spectator, 1 = players enter queue" "value"
setdesc "maxaliveminimum" "only enables maxalive limit if the number of players is more than or equal to this" "value"
setdesc "maxalivethreshold" "only enables maxalive limit if the number of players is more than or equal to this*numplayers (for current map)" "value"
setdesc "spawnrotate" "spawn point rotation;^n0 = let client decide, 1 = sequence, 2 = random" "value"
setdesc "spawnprotect" "time in milliseconds after spawning players cannot be damaged" "milliseconds"
setdesc "duelprotect" "time in milliseconds after spawning players cannot be damaged in duel/survivor matches" "milliseconds"
setdesc "instaprotect" "time in milliseconds after spawning players cannot be damaged in instagib matches" "milliseconds"
setdesc "instaresizeamt" "each kill adds this much size in insta-resize" "value"
setdesc "regendelay" "time in milliseconds after being damage before normal regeneration resumes" "milliseconds"
setdesc "regentime" "time in milliseconds for which regenerate gives health" "milliseconds"
setdesc "regenhealth" "amount of health regeneration gives" "value"
setdesc "regendecay" "if over maxhealth, decay this amount each regen" "value"
setdesc "kamikaze" "determines the level of kamikaze events;^n0 = never, 1 = holding grenade, 2 = have grenade, 3 = always" "value"
setdesc "itemspawntime" "time in milliseconds before items (re)spawn" "milliseconds"
setdesc "itemspawndelay" "time in milliseconds after map start items first spawn" "milliseconds"
setdesc "itemspawnstyle" "determines the timing of item spawning at map start;^n0 = all at once, 1 = staggered, 2 = random, 3 = randomise between both" "value"
setdesc "timelimit" "time in minutes before round ends;^n0 = off" "minutes"
setdesc "overtimeallow" "if scores are equal, go into overtime" "value"
setdesc "overtimelimit" "maximum time overtime may last, 0 = forever" "minutes"
setdesc "intermlimit" "time in milliseconds intermission lasts" "milliseconds"
setdesc "votelimit" "time in milliseconds intermission voting lasts" "milliseconds"
setdesc "duelreset" "determines if duel/survivor winner should be sent back to respawn for next round" "value"
setdesc "duelclear" "determines if items are reset at the end of each round" "value"
setdesc "duelcooloff" "cool off period before duel goes to next round" "milliseconds"
setdesc "duelcycle" "determines if players are force-cycled after a certain number of wins (0 = off, 1 = non-team games, 2 = team games, 3 = both)" "value"
setdesc "duelcycles" "maximum wins in a row before force-cycling (0 = num team/total players)" "value"
setdesc "damageself" "determines if the player can damage themselves;^n0 = off, 1 = either hurt self or use damageteam rules" "value"
setdesc "damageselfscale" "determines how much self-damage is dealt;^n0 = off, anything else = scale for damage" "value"
setdesc "damageteamscale" "determines how much team damage is dealt;^n0 = off, anything else = scale for damage" "value"
setdesc "teambalance" "determines the method of team balancing; style is a player ranking (see balancestyle);^n 0 = off, 1 = by number then style, 2 = by style then number, ^n3 = by number, using swap requests, 4 = same as 3, and reassign players if necessary,^n 5 = same as 4, but by style, then number, 6 = by style during waiting, revert to 4 otherwise
setdesc "teambalancestyle" "determines the method of sorting for team balancing;^n  0 = top of list, 1 = time played, 2 = points, 3 = frags, 4 = scoretime, 5 = kdratio, 6 = combined kdratio" "value"
setdesc "teambalancehighest" "determines if team balancing moves the highest players in the balance sort" "value"
setdesc "teambalanceduel" "allow reassignments in duel" "bool"
setdesc "teambalanceplaying" "min players before reassignments occur" "number"
setdesc "teambalanceamt" "max-min offset for players per team before reassignments occur" "value"
setdesc "teambalancewait" "how long before reassignment can happen again" "ms"
setdesc "teambalancedelay" "how long before reassignments start" "ms"
setdesc "teambalanceswap" "allow swap requests if unable to change team" "bool"
setdesc "teambalancelock" "level at which one can override swap" "rank"
setdesc "teampersist" "when a player leaves and rejoins the game, automatically put them on the same team they had before;^n0 = off, 1 = only attempt, 2 = forced" "value"
setdesc "pointlimit" "number of points required to end the round (and win) in deathmatch modes" "value"
setdesc "capturelimit" "number of captures required to end the round (and win) in ctf" "value"
setdesc "capturepoints" "points added to score for capturing flag" "value"
setdesc "capturepickuppoints" "points added to score for picking up enemy flag" "value"
setdesc "capturethreshold" "automatically drop the flag if the flag-carrier ^"warps^" more than this distance" "distance"
setdesc "capturebuffing" "buff circumstances" "[near own flag at its base] [near own loose flag] [holding own flag] [near teammate holding own flag] [holding enemy flag] [near teammate holding enemy flag]"
setdesc "capturebuffdelay" "buffed when guarding, and for this long after" "milliseconds"
setdesc "capturebuffarea" "multiply affinity radius by this much for buff" "value"
setdesc "capturebuffdamage" "multiply outgoing damage by this much when buffed" "value"
setdesc "capturebuffshield" "divide incoming damage by this much when buffed" "value"
setdesc "captureregenbuff" "0 = off, 1 = modify regeneration when buffed" "value"
setdesc "captureregendelay" "regen this often when buffed" "milliseconds"
setdesc "captureregenextra" "add this to regen when buffed" "value"
setdesc "defendlimit" "determines the style of dac play;^nnumber of points required to end the round (and win) in dac" "value"
setdesc "defendinterval" "time in milliseconds to add one tick to the secure gauge" "milliseconds"
setdesc "defendpoints" "number of points given in dac" "value"
setdesc "defendoccupy" "ticks needed to overthrow or secure a control area" "value"
setdesc "defendking" "ticks needed to secure in king-of-the-hill" "value"
setdesc "defendhold" "ticks an area must remain secured in order to score" "value"
setdesc "defendflags" "flags to init and how;^n0 = init all (neutral), 1 = init neutral and team only, 2 = init team only, 3 = init all (team + neutral + converted)" "value"
setdesc "defendbuffing" "buff circumstances" "[when guarding] [when securing] [even when enemies are present]"
setdesc "defendbuffoccupy" "if defendbuffing = 4, must be occupied this much before passing" "milliseconds"
setdesc "defendbuffdelay" "buffed for this long after leaving" "milliseconds"
setdesc "defendbuffarea" "multiply affinity radius by this much for buff" "value"
setdesc "defendbuffdamage" "multiply outgoing damage by this much when buffed" "value"
setdesc "defendbuffshield" "divide incoming damage by this much when buffed" "value"
setdesc "defendregenbuff" "0 = off, 1 = modify regeneration when buffed" "value"
setdesc "defendregendelay" "regen this often when buffed" "milliseconds"
setdesc "defendregenextra" "add this to regen when buffed" "value"
setdesc "bomberlimit" "finish when score is this or more (non-hold)" "value"
setdesc "bomberholdlimit" "finish when score is this or more (hold)" "value"
setdesc "bomberpoints" "points added to score for a goal" "value"
setdesc "bomberthrowinpoints" "points team gets for scoring with throw-in in basket" "value"
setdesc "bombertouchdownpoints" "points team gets for scoring with touchdown in basket" "value"
setdesc "bomberpenalty" "points taken from score for throwing the bomb into your own goal" "value"
setdesc "bomberpickuppoints" "points added to score for picking up the bomb" "value"
setdesc "bomberholdpoints" "points added to score for each interval (hold)" "value"
setdesc "bomberholdpenalty" "points subtracted for having the bomb fuse run out (hold)" "value"
setdesc "bomberthreshold" "automatically drop the bomb if the bomb-carrier ^"warps^" more than this distance" "distance"
setdesc "bomberbuffing" "buff circumstances" "[when near own base] [when holding bomb] [when holding bomb as the defenders (attack only)]"
setdesc "bomberbuffdelay" "buffed for this long after leaving" "milliseconds"
setdesc "bomberbuffarea" "multiply affinity radius by this much for buff" "value"
setdesc "bomberbuffdamage" "multiply outgoing damage by this much when buffed" "value"
setdesc "bomberbuffshield" "divide incoming damage by this much when buffed" "value"
setdesc "bomberregenbuff" "0 = off, 1 = modify regeneration when buffed" "value"
setdesc "bomberregendelay" "regen this often when buffed" "milliseconds"
setdesc "bomberregenextra" "add this to regen when buffed" "value"
setdesc "bombercarryspeed" "scales the movement speed of the player carrying the bomber ball by this value" "value"
setdesc "bombercarrytime" "time in milliseconds a player can carry the bomber ball before it explodes" "milliseconds"
setdesc "bomberholdinterval" "time in milliseconds a player needs to hold the ball in hold bomber-ball to get a point" "milliseconds"
setdesc "bomberpickupdelay" "time in milliseconds a player needs to wait to be able to pick up the bomber ball again after dropping it" "milliseconds"
setdesc "bomberresetdelay" "time in milliseconds before the bomber ball resets after being dropped" "milliseconds"
setdesc "bomberspeed" "speed at which the bomber ball moves when thrown or dropped;^nfor reference, 125 is the speed the player moves at by default" "value"
setdesc "enemyspawntime" "determine length of time before enemies respawn" "milliseconds"
setdesc "enemyspawndelay" "determine length of time after map start enemies first spawn" "milliseconds"
setdesc "enemyspawnstyle" "determines enemy spawning style, 0 = all at once, 1 = staggered, 2 = random, 3 = randomise between both" "value"
setdesc "movespeed" "baseline movement speed" "value"
setdesc "movecrawl" "multiplier of speed when crawling" "value"
setdesc "movestraight" "multiplier of speed when only moving forward" "value"
setdesc "movestrafe" "multiplier of speed when strafing" "value"
setdesc "moveinair" "multiplier of speed when in-air" "value"
setdesc "movestepup" "multiplier of speed when stepping up" "value"
setdesc "movestepdown" "multiplier of speed when stepping down" "value"
setdesc "jumpspeed" "extra velocity to add when jumping" "value"
setdesc "impulsespeed" "extra velocity to add when impulsing" "value"
setdesc "impulselimit" "maximum impulse speed" "value"
setdesc "impulseboost" "multiplier of impulse when just boosting" "value"
setdesc "impulsepower" "power jump modifier" "value"
setdesc "impulsedash" "multiplier of impulse when dashing" "value"
setdesc "impulsejump" "multiplier of impulse when jumping" "value"
setdesc "impulseparkour" "multiplier of impulse when doing other parkour" "value"
setdesc "impulseparkourkick" "parkour kick modifier" "value"
setdesc "impulseparkourvault" "parkour vault modifier" "value"
setdesc "impulseparkournorm" "minimum parkour surface z normal" "value"
setdesc "impulsestyle" "impulse style;^n0 = off, 1 = touch and count, 2 = count only, 3 = freestyle" "value"
setdesc "impulsecount" "number of impulse actions per air transit" "value"
setdesc "impulseslip" "time before floor friction kicks back in" "milliseconds"
setdesc "impulseslide" "time before powerslides end" "milliseconds"
setdesc "impulsedashdelay" "minimum time between dashes/powerslides" "milliseconds"
setdesc "impulsekickdelay" "minimum time between wall kicks/climbs" "milliseconds"
setdesc "impulsevaultmin" "minimum percentage of height for vault" "value"
setdesc "impulsevaultmax" "maximum percentage of height for vault" "value"
setdesc "impulsemelee" "multiplier of impulse when using melee" "value"
setdesc "impulsemeter" "impulse dash length;^n0 = unlimited, anything else = timer" "value"
setdesc "impulsecost" "cost of impulse jump" "value"
setdesc "impulseskate" "length of time a run along a wall can last" "value"
setdesc "impulseregen" "impulse regen multiplier" "value"
setdesc "impulseregencrouch" "impulse regen modifier when crouching" "value"
setdesc "impulseregenmove" "impulse regen modifier when moving" "value"
setdesc "impulseregeninair" "impulse regen modifier when in air" "value"
setdesc "impulseregendelay" "delay before impulse regens" "value"
setdesc "impulseregendelay" "delay before impulse regens" "value"
setdesc "autoscores" "1 = when dead, 2 = also in spectv, 3 = and in waittv too" "value"
setdesc "scoresdelay" "otherwise use respawn delay" "milliseconds"
setdesc "showlaptimes" "0 = off, 1 = only player, 2 = +humans, 3 = +bots" "value"
setdesc "muzzleflash" "0 = off, 1 = only other players, 2 = only thirdperson, 3 = all" "value"
setdesc "muzzleflare" "0 = off, 1 = only other players, 2 = only thirdperson, 3 = all" "value"
setdesc "showdamage" "1 shows just damage texture, 2 blends as well" "value"
setdesc "showcrosshair" "0 = off, 1 = on, 2 = blend depending on current accuracy level" "value"
setdesc "crosshairweapons" "0 = off, 1 = crosshair-specific weapons, 2 = also appy colour" "value"
setdesc "cursorstyle" "0 = top left tracking, 1 = center" "value"
setdesc "radarhardaffinity" "0 = no radar in hard, 1 = affinity only radar in hard" "value"
setdesc "animationinterpolationtime" "sets the duration in milliseconds of animation blending" "value"
setdesc "addpostfx" "adds this effect to the post-processing stack" "value"
setdesc "setpostfx" "replaces all the current post-processing effects with this one" "value"
setdesc "clearpostfx" "clears all post-processing effects"
setdesc "musictype" "0 = no in-game music, 1 = map music (or random if none), 2 = always random, 3 = map music (silence if none), 4-5 = same as 1-2 but pick new tracks when done" "value"
setdesc "musicedit" "0 = no editing music, 1 = map music (or random if none), 2 = always random, 3 = map music (silence if none), 4-5 = same as 1-2 but pick new tracks when done" "value"
setdesc "followdead" "0 = never, 1 = in all but duel/survivor, 2 = always" "value"
setdesc "specmode" "0 = float, 1 = tv" "value"
setdesc "waitmode" "0 = float, 1 = tv in duel/survivor, 2 = tv always" "value"
setdesc "spectvrotate" "rotate style,  0 = absolute angle, 0 = scaled, gt 0 = scaled with max angle" "value"
setdesc "spectvdead" "0 = never, 1 = in all but duel/survivor, 2 = always" "value"
setdesc "deathcamstyle" "0 = no follow, 1 = follow attacker, 2 = follow self" "value"
setdesc "zoomdefault" "-1 = last used, else defines default level" "value"
setdesc "zoomscroll" "0 = stop at min/max, 1 = go to opposite end" "value"
setdesc "showobituaries" "0 = off, 1 = only me, 2 = 1 + announcements, 3 = 2 + but dying bots, 4 = 3 + but bot vs bot, 5 = all" "value"
setdesc "obitannounce" "0 = off, 1 = only focus, 2 = everyone" "value"
setdesc "obitverbose" "0 = extremely simple, 1 = simplified per-weapon, 2 = regular messages" "value"
setdesc "obitstyles" " 0 = no obituary styles, 1 = show sprees/dominations/etc" "value"
setdesc "showpresence" "0 = never show join/leave, 1 = show only during game, 2 = show when connecting/disconnecting" "value"
setdesc "showpresencehostinfo" "0 = do not show host info in join/leave messages, 1 = show host info in join/leave messages when at an appropriate privilege level" "value"
setdesc "showteamchange" "0 = never show, 1 = show only when switching between, 2 = show when entering match too" "value"
setdesc "deathanim" "0 = hide player when dead, 1 = old death animation, 2 = ragdolls, 3 = ragdolls, but hide in duel/survivor" "value"
setdesc "deathfade" "0 = don't fade out dead players, 1 = fade them out" "value"
setdesc "deathscale" "0 = don't scale out dead players, 1 = scale them out" "value"
setdesc "gravity" "gravity" "value"
setdesc "impulsekick" "determines the minimum angle to switch between wall kick and run" "angle"
setdesc "impulsemethod" "determines which impulse method to use, 0 = none, 1 = power jump, 2 = power slide, 3 = both" "value"
setdesc "impulseaction" "determines how impulse action works, 0 = off, 1 = impulse jump, 2 = impulse dash, 3 = both" "value"
setdesc "impulseroll" "determines the camera angle tilt when wallrunning" "angle"
setdesc "dashstyle" "0 = only with impulse, 1 = double tap, 2 = double tap when not falling" "value"
setdesc "crouchstyle" "0 = press and hold, 1 = double-tap toggle, 2 = toggle" "value"
setdesc "walkstyle" "0 = press and hold, 1 = double-tap toggle, 2 = toggle" "value"
setdesc "kickoffstyle" "client side option for wall jumps. 0 = fixed angle, 1 = direction of view" ""
setdesc "kickoffangle" "wall jump angle for kickoffstyle = 0" ""
setdesc "kickupstyle" "client side option for wall kicks or climbing. 0 = fixed angle, 1 = direction of view" ""
setdesc "kickupangle" "wall kick/climb angle for kickoffstyle = 0" ""
setdesc "grabstyle" "setting for angle of parkour grabs; 0 = up and down ; 1 = inverted up and down ;  2 = only upwards, like wall kicks" ""
setdesc "showentdir" "0 = off, 1 = only selected, 2 = always when editing, 3 = always in editmode" "value"
setdesc "aboveheadblend" "determines the opacity of all abovehead* vars" "value"
setdesc "aboveheaddamage" "shows amount of damage done to a player above their head" "value"
setdesc "aboveheadeventsize" "determines the size of event icons above players' heads" "value"
setdesc "aboveheadicons" "detemines what type of actions displays icons above players" "[damage & kill events] [affinity pickups] [weapons pickups]"
setdesc "aboveheadiconssize" "determines the size of icons handled by aboveheadicons" "value"
setdesc "aboveheadnames" "toggles the display of player names above their heads" "value"
setdesc "aboveheadnamessize" "determines the size of names for aboveheadnames" "value"
setdesc "aboveheadstatus" "toggles display of player status above players' heads, player status is dominating, dominated, death" "value"
setdesc "aboveheadstatussize" "determines the size of player status controlled by aboveheadstatus" "value"
setdesc "aboveheadteam" "determines how team icons are displayed above player heads;^n0 = do not show, 1 = only teammates, 2 = all teams" "value"
setdesc "allconsole" "display console messages in the hud without manually opening the console" "value"
setdesc "bloodsize" "sets the size of blood splatter" "value"
setdesc "dominatetex" "determines what image is used for the ^"dominating!^" event icon" "value"
setdesc "dominatedtex" "determines what image is used for the icon that appears over a player's head while dominating" "value"
setdesc "dominatingtex" "determines what image is used for the icon that appears over a player's head while being dominated" "value"
setdesc "eventblend" "sets the opacity of event icons, (first blood, 2x, 3x, headshot, etc.)" "value"
setdesc "eventiconfade" "sets how long event icons should stay on screen" "value"
setdesc "eventoffset" "sets the offset for the event icons in your hud, negative values move it downward, positive values move it upward" "value"
setdesc "eventscale" "sets the scale of event icons that appear in your hud" "value"
setdesc "fullconsole" "display console messages in the hud without manually opening the console, will prevent lines from fading" "value"
setdesc "hudblend" "sets the opacity of the entire hud as a whole, this includes both consoles, mouse pointer, and inventory" "value"
setdesc "hudsize" "sets the size of the entire hud as a whole, this includes both consoles, menus, inventory, etc" "value"
setdesc "noticescale" "sets the size of the notices" "value"
t = "Sets a colour according to the player's chosen profile colour and current team; ^n-1 = force profile colour, no special tones applied; ^n0 = team colour; ^n1 = profile colour; ^n2 = profile colour when neutral, team when teamed; ^n3 = neutral colour when neutral, profile when teamed; ^n4 = mix of profile and team colour; ^n5 = profile colour when neutral, mixed colour when teamed; ^n6 = mixed colour when neutral, profile colour when teamed"
setdesc "playerovertone" (concat "primary colour tone of player models." $t) "value"
setdesc "playerundertone" (concat "secondary colour tone of player models." $t) "value"
setdesc "playerhinttone" (concat "glow effect (halo) on player models." $t) "value"
setdesc "playereffecttone" (concat "particle colour of player trails and spawns." $t) "value"
setdesc "playerteamtone" (concat "team icon colour, if enabled via aboveheadteam." $t) "value"
setdesc "playertonemix" "mixing value for colour tones on player models. Used if a player tone variable takes a value of 4, 5 or 6." "value"
setdesc "showfps" "display the frames per second counter on the hud;^n0 = no display, 1 = display average fps, 2 = display average fps along with best and worst difference" "value"
setdesc "showvelocity" "display the velocity indicator on the hud" "value"
setdesc "showconsole" "display the console" "value"
setdesc "zoomsensitivity" "determines aiming/look sensitivity while zoomed in with the rifle" "value"
setdesc "zoomtex" "determines what image is used for the scope on the rifle" "value"
setdesc "playerscale" "defines the size of players" "value"
setdesc "botscale" "defines the size of bots" "value"
setdesc "adminpass" "sets server admin password, if no password given, it will return the current password" "value"
setdesc "captureresetdelay" "time in milliseconds before a dropped flag automatically resets" "milliseconds"
setdesc "maxhealth" "spawnhealth * maxhealth defines the maximum amount of health that can be reached (e.g. standing next to a friendly goal)" "value"
setdesc "maxhealthvampire" "spawnhealth * maxhealthvampire defines the maximum amount of health that can be reached by damaging other players in vampire" "value"
setdesc "minresizescale" "defines the smallest scaled size a player can become in a match with the resize mutator enabled" "value"
setdesc "maxresizescale" "defines the largest scaled size a player can become in a match with the resize mutator enabled" "value"
setdesc "checkpointspawn" "determines if you will respawn at checkpoints after material deaths" "value"
setdesc "duelmaxqueued" "number of players that can be queued for duel. 0 = any number of players"
setdesc "survivormaxqueued" "number of players that can be queued for survivor. 0 = any number of players"
//material
setdesc "editmat" "modifies the material properties for selected cubes;^ntype is the material to be applied {water, clip, ladder, etc.},^nfilter limits the command to only affect cubes whose material match this, if given as empty string ^"^" it matches all,^nstyle limits the command to only affect cubes whose geometry match this {0 = normal, 1 = non-empty, 2 = empty, 3 = not entirely solid, 4 = entirely solid},^nexample: editmat air water 2 would set all empty cubes with water within the current selection to instead be air" "type [filter style]"
setdesc "showmat" "toggles the visibility of material volumes" "value"
setdesc "air" "modifies the material properties for the selected cubes;^nfilter limits the command to only affect cubes whose material match this {water, clip, ladder, etc.}" "[filter]"
loop i 4 [
    setdesc [water@(? $i (+ $i 1))] "modifies the material properties for the selected cubes;^nfilter limits the command to only affect cubes whose material match this {water, clip, ladder, etc.}" "[filter]"
    setdesc [glass@(? $i (+ $i 1))] "modifies the material properties for the selected cubes;^nfilter limits the command to only affect cubes whose material match this {water, clip, ladder, etc.}" "[filter]"
    setdesc [lava@(? $i (+ $i 1))] "modifies the material properties for the selected cubes;^nfilter limits the command to only affect cubes whose material match this {water, clip, ladder, etc.}" "[filter]"
]
setdesc "clip" "modifies the material properties for the selected cubes;^nfilter limits the command to only affect cubes whose material match this {water, clip, ladder, etc.}" "[filter]"
setdesc "noclip" "modifies the material properties for the selected cubes;^nfilter limits the command to only affect cubes whose material match this {water, clip, ladder, etc.}" "[filter]"
setdesc "death" "modifies the material properties for the selected cubes;^nfilter limits the command to only affect cubes whose material match this {water, clip, ladder, etc.}" "[filter]"
setdesc "aiclip" "modifies the material properties for the selected cubes;^nfilter limits the command to only affect cubes whose material match this {water, clip, ladder, etc.}" "[filter]"
setdesc "ladder" "modifies the material properties for the selected cubes;^nfilter limits the command to only affect cubes whose material match this {water, clip, ladder, etc.}" "[filter]"
setdesc "alpha" "modifies the material properties for the selected cubes;^nfilter limits the command to only affect cubes whose material match this {water, clip, ladder, etc.}" "[filter]"

setdesc "serverclients" "maximum number of allowed clients" "value"
setdesc "serverdesc" "server description" "text"
setdesc "servermotd" "server message of the day" "text"
setdesc "serveropen" "determines server openness for public use;^n0 = allow ^"setpriv 1^" and locked/private, 1 = allow ^"setpriv 1^" but no privileged mode, no locked/private, 2 = allow ^"setpriv 1^" but disallows private privileged mode (for public coop-editing), 3 = privilege only by moderator or above" "value"
setdesc "autoadmin" "determines if authorities claim status by default" "value"
setdesc "aihostnum" "multiply number of bots hosted by this much for the bot hosting decision" "value"
setdesc "aihostping" "multiply host ping by this much for the bot hosting decision" "value"
setdesc "aihostshift" "require this difference before shifting bot hosts" "value"
setdesc "airefreshdelay" "delay imposed before the AI manager reorganises their setup" "milliseconds"
setdesc "modelockfilter" "determines the modes which are allowed to be used as dictated by modelock,^nconvenient to set using a sum of $modebit* vars,^nexample: (+ $modebitediting $modebitdeathmatch)" $modeidxname
setdesc "mutslockfilter" "determines the mutators which are allowed to be used as dictated by modelock,^nconvenient to set using a sum of $mutsbit* vars" (concat $mutsidxname mode-specific1 mode-specific2 mode-specific3)
setdesc "gamespeed" "percentage of default gameplay speed" "value"
setdesc "gamepaused" "pauses the game, automatically unset by server" "value"
setdesc "defaultmap" "default map, ^"^" = random" "map"
setdesc "defaultmode" "default game mode;^n1 = editing, 2 = deathmatch, 3 = ctf, 4 = dac, 5 = bomber, 6 = race" "value"
setdesc "defaultmuts" "default mutators, convenient to set using a sum of $mutsbit* vars" (concat $mutsidxname mode-specific1 mode-specific2 mode-specific3)
setdesc "forcemapvariant" "force selection of a particular variant when loading maps, will change current variant if called when a map is loaded;^n0 = random, 1 = day, 2 = night" "value"
setdesc "rotatemaps" "determines behaviour of map rotation;^n0 = off, 1 = sequence, 2 = random" "value"
setdesc "rotatemapsfilter" "0 = off, 1 = filter based on mutators, 2 = also filter based on players" "value"
setdesc "rotatemode" "determines if modes rotate when the server selects the next map" "value"
setdesc "allowmaps" "determines which maps are allowed to be chosen without elevated privileges" "list"
setdesc "mainmaps" "deathmatch maps" "list"
setdesc "capturemaps" "capture-the-flag maps" "list"
setdesc "defendmaps" "defend-the-flag maps" "list"
setdesc "bombermaps" "bomber-ball maps" "list"
setdesc "holdmaps" "hold bomber-ball maps" "list"
setdesc "racemaps" "race maps" "list"
setdesc "duelmaps" "duel map filter (extra filter on top of mode filter)" "list"
setdesc "burntime" "time in milliseconds fire burns for, try to allow an extra 500ms breathing room for sync" "milliseconds"
setdesc "burndelay" "time in milliseconds for which fire burning deals damage" "milliseconds"
setdesc "burndamage" "amount of damage fire burning deals" "value"
setdesc "bleedtime" "time in milliseconds bleeding lasts for, try to allow an extra 500ms breathing room for sync" "milliseconds"
setdesc "bleeddelay" "time in milliseconds for which bleeding deals damage" "value"
setdesc "bleeddamage" "amount of damage bleeding deals" "value"
setdesc "bleedtime" "time in milliseconds shocking lasts for, try to allow an extra 500ms breathing room for sync" "milliseconds"
setdesc "bleeddelay" "time in milliseconds for which shocking deals damage" "value"
setdesc "bleeddamage" "amount of damage shocking deals" "value"
setdesc "botskillmin" "minimum randomly assigned AI skill level" "value"
setdesc "botskillmax" "maximum randomly assigned AI skill level" "value"
setdesc "coopskillmin" "minimum randomly assigned AI skill level in coop" "value"
setdesc "coopskillmax" "maximum randomly assigned AI skill level in coop" "value"
setdesc "enemyskillmin" "minimum randomly assigned skill level for neutral actors in onslaught" "value"
setdesc "enemyskillmax" "maximum randomly assigned skill level for neutral actors in onslaught" "value"
setdesc "botlimit" "maximum number of bots allowed, regardless of any other variable/setting" "value"
setdesc "botbalance" "determines bot balancing method;^n-1 = always use numplayers, 0 = don't balance, 1 or more = fill only with this*numteams" "value"
looplist i [player bot drone grunt turret] [
    setdesc (concatword $i abilities) (format "allowed actions for %1s." $i) "move jump crouch dash boost parkour melee  primary-fire secondary-fire push-/stunable affinity regen claw"
    setdesc (concatword $i collide) "determines which targets can be attacked" "players bots enemies"
    setdesc (concatword $i teamdamage) "determines which targets can take team damage" "players bots enemies ghosts"
    setdesc (concatword $i health) "spawn health" "value"
    setdesc (concatword $i scale) "actor model scale, also scales movement speed accordingly" "value"
    setdesc (concatword $i speed) "base movement speed" "value"
    setdesc (concatword $i vname) "generic name for system messages" "string"
    setdesc (concatword $i spawngrenades) "spawn with grenades;^n0 = never, 1 = all but instagib/race, 2 = always" "value"
    setdesc (concatword $i spawnmines) "spawn with mines;^n0 = never, 1 = all but instagib/race, 2 = always" "value"
    setdesc (concatword $i weaponspawn) "weapon players spawn with, defaults to pistol (1)" "value"
    setdesc (concatword $i weaponinsta) "weapon players spawn with in instagib, defaults to rifle (8)" "value"
    setdesc (concatword $i weaponrace) "weapon players spawn with in race, defaults to claw (0)" "value"
    setdesc (concatword $i weapongladiator) "weapon players spawn with in gladiator, defaults to claw (0)" "value"
    setdesc (concatword $i weaponkaboom) "weapon players spawn with in gladiator, defaults to grenades (9)" "value"
    setdesc (concatword $i weaponmedieval) "weapon players spawn with in medieval, defaults to sword (2)" "value"
    setdesc (concatword $i spawndelay) "time in milliseconds before respawn in most modes" "millisecond"
    setdesc (concatword $i spawndelayinstascale) "time multiplier before respawn in instagib mutated modes" "value"
    setdesc (concatword $i spawndelaycapture) "time in milliseconds before respawn in capture mode" "milliseconds"
    setdesc (concatword $i spawndelaybomber) "time in milliseconds before respawn in bomber mode" "milliseconds"
    setdesc (concatword $i spawndelaydefend) "time in milliseconds before respawn in defend mode" "milliseconds"
    setdesc (concatword $i spawndelayrace) "time in milliseconds before respawn in race mode" "milliseconds"
    setdesc (concatword $i spawndelaygauntlet) "time in milliseconds before respawn in gauntlet mode" "milliseconds"
]
setdesc "enemybalance" "multiply number of enemy spawns by this much" "value"
setdesc "gravityscale" "multiply gravity by this much" "value"
setdesc "liquidspeedscale" "multiply liquidspeed by this much" "value"
setdesc "liquidcoastscale" "multiply liquidcoast by this much" "value"
setdesc "floorcoastscale" "multiply floorcoast by this much" "value"
setdesc "aircoastscale" "multiply aircoast by this much" "value"
setdesc "slidecoastscale" "multiply slidecoast by this much" "value"
setdesc "radialscale" "multiply explosion radius by this amount" "value"
setdesc "radiallimited" "multiply explosion radius by this amount in limited situations (eg. instagib)" "value"
setdesc "damagescale" "scale damage by this amount" "value"
setdesc "hitpushscale" "scale hit pushes by this amount" "value"
setdesc "hitstunscale" "multiply ^"stun target on hit^" by this amount" "value"
setdesc "deadpushscale" "scale hit pushes by this amount when it results in a frag" "value"
setdesc "wavepushscale" "scale of the hitpush force used in a wavepush" "value"
setdesc "kickpushscale" "multiply kick pushes from weapons by this much" "value"
setdesc "kickpushcrouch" "multiply kick pushes from weapons by this much when crouching" "value"
setdesc "kickpushsway" "multiply kick push effect on hud gun sway by this much" "value"
setdesc "kickpushzoom" "multiply kick pushes from weapons by this much when zoomed" "value"
setdesc "lasthitdelay" "time in milliseconds before a hit no longer is counted as a last hit" "value"
setdesc "multikilldelay" "time in milliseconds multiple kills in a row must occur" "value"
setdesc "spreecount" "number of consecutive frags for each spree level" "value"
setdesc "dominatecount" "number of frags on a single player without revenge before it is considered domination" "value"
setdesc "firstpersonfov" "determines the size of the field of view in first person mode" "angle"
setdesc "fov" "determines the size of the field of view in first or third person mode, depending on the current camera mode" "angle"
//clients
setdesc "getclientnum" "returns a client number (your own if name is ^"^")" "name/cn"
setdesc "getclientcolour" "returns the color of a player in HEX format" "name/cn"
setdesc "getclienthandle" "returns the auth handle of a player" "name/cn"
setdesc "getclientip" "returns the ip address of a player" "name/cn"
setdesc "getclienthost" "returns the hostmask of a player" "name/cn"
setdesc "getclientmodel" "returns the model number of a player's chosen player model" "name/cn"
setdesc "getclientname" "returns the name of the player; filter: 0 = without priv icon, 1 = with priv icon^necxample: getclientname 2 1" "name/cn [filter]"
setdesc "getclientversion" "returns specific information of a player^nid: 0 = major version, 1 = minor version, 2 = patch version, 3 = game version, 4 = platform (0 = Windows, 1 = OS X, 2 = Unix-like), 5 = architecture^n6 = OpenGL version, 7 = OpenGL shader version, 8 = CRC checksum, 9 = GPU vendor, 10 = GPU, 11 = GPU version, 12 = platform short form^n13 = game version, platform, architecture" "name/cn id"
setdesc "getclientvanity" "returns the vanities of a player" "name/cn"
setdesc "getclientweapselect" "returns a player's currently selected loadout" "name/cn"
setdesc "getclientloadweap" "returns the weaponid of slot in the loadout of a player" "name/cn slot"
setdesc "getclientteam" "returns the team number of a player (1 = alpha, 2 = omega, 3 = kappa, 4 = sigma)" "name/cn"
setdesc "getmodelname" "returns the model name from a model number, the second argument determines which bits of the path to the model file is printed, defaults to 2;^n0 = path to model directory, 1 = path to model/hwep directory, name of model directory" "modelnumber value"
setdesc "listclients" "returns a list with client numbers from actual server^n boolean: 0 = Adds your cn, 1 = Adds your cn as the first item^n filter: 0 = off, 1 = enemies, 2 = all ai" "[bool] [filter]"
//editing
setdesc "newent" "create a new entity (available: light, mapmodel, playerstart, envmap, particles, sound, lightfx, sunlight, weapon, teleport, actor, trigger, pusher, affinity, checkpoint, dummy1, dummy2)" "type properties..."
setdesc "entset" "set type and properties of the currently selected entity" "type properties..."
setdesc "skylight" "set colour and brightness of a uniform downwards-facing lightsource spanning the whole sky" "value"
setdesc "ambient" "set colour and brightness of a uniform ambient light throughout the whole map" "value"
setdesc "entfind" "selects all entities of a specific type and optionally with specific properties, using ^"1^" as type selects all entities" "type properties..."
setdesc "entfindinsel" "selects all entities, within the selected area, of a specific type and optionally with specific properties, using ^"1^" as type selects all entities" "type properties..."
setdesc "entcancel" "deselects all entities while leaving area selected"
setdesc "savemap" "saves the current map as ^"mapname.mpz^" in the homedir" "map"
setdesc "maptitle" "sets the title message of the map" "text"
setdesc "mapauthor" "sets the author message of the map" "text"
setdesc "mapenlarge" "enlarges the map to twice the size" "text"
setdesc "shrinkmap" "shrinks the map size to smallest cubed area, only empty space outside of the map will be removed"
setdesc "sendmap" "manually sends map to the server"
setdesc "getmap" "manually retrieves map from the server"
setdesc "gettex" "picks up the texture from the face currently selected, note that allfaces must be turned off"
setdesc "vscale" "replaces selected textures with scaled versions, minimum is 0.125, maximum is 8" "value"
setdesc "vrotate" "replaces selected textures with clockwise rotated or flipped versions;^n0 = default, 1-3 = rotate 90*this degrees, 4 = flipped left-to-right, 5 = flipped top-to-bottom" "value"
setdesc "vcolour" "replaces selected textures with colour-tinted versions,^ne.g. 1 0.2 0.2 will create red versions, default is 1 1 1" "red green blue"
setdesc "vpalette" "applies the colour specified by set and id from the builtin palette;^nset 0 = pulse colours {0 = turn off all palette effects, 1 = dark fire pulse colours, 2 = bright fire pulse colours, 3 = disco pulse colours (bomber-ball)},^nset 1 = team colours {0-3 = only enforced in teamplay games 4-7 = enforced at all times},^nset 2 = weapon colours {0-9 = only enforced when that weapon is able to spawn in the current game configuration 10-19 = enforced at all times}" "set id"
setdesc "vreset" "resets a vtexture to its original settings"
setdesc "replace" "repeats the last texture change across the entire map, note that allfaces must be turned off"
setdesc "vdelta" "combines with texture v*-commands to adjust rather than overwrite the setting;^nexample: vdelta [vcolour 1 .5 .5]^nexample: vdelta [voffset 0 +16]" "command settings..."
setdesc "vshaderparam" "set shader parameters of textures;^nindependent of vdelta, only one shader parameter may be overridden per texture, previous modifications are lost^nspecscale red green blue = specularity colour and brightness of a texture {example: vshaderparam specscale 0.2 0.2 1.1 creates a blue shine, specscale 0.2 0.2 0.2 resets},^nparallaxscale low high = adjusts the 3d heightmap effect of a texture,^nglowcolor red green blue = adjusts the 3d glow colour of a texture" "parameter properties"
setdesc "vlayer" "Sets the bottom texture layer for all textures in the current selection;^ntexture_id is the number of the texture as seen in the texture browser" "texture_id"
setdesc "texturecull" "removes all textures not used in the map from the map config file"
setdesc "grasscolour" "sets the colour of grass" "hexcolour"
setdesc "grassheight" "sets the height of grass" "value"
setdesc "grassblend" "sets the opacity of grass" "value"
setdesc "grassdist" "sets the distance at which grass becomes visible" "value"
setdesc "calclight" "create and apply lightmap for all textures.^nquality option: 1 highest (default), 0 = custom (see lmaa and lmshadows), -1 = lowest^nquick option: 0 = use current lightprecision (default),  1 = use lightprecisionquick (very coarse)"  "quality quick"
setdesc "fullbright" "hides lightmap for all textures if enabled"
setdesc "selectbrush" "select a different brush with relative index to the current one;^n-1 = previous brush, 1 = next brush" "index"
setdesc "skybox" "loads a set of 6 images associated by name from the specified basepath;^ne.g. ^"skyboxes/gradient^" will load gradient_{up,dn,lf,rt,bk,ft}.{png,jpg}" "basepath"
setdesc "skycolour" "changes the colour of the skybox" "hexcolour"
setdesc "yawsky" "determines the placement of the skybox (move the sun's placement)"
setdesc "spinsky" "controls the speed at which the skybox turns"
setdesc "cloudlayer" "loads a specified image to tile as a cloud layer" "file"
setdesc "cloudheight" "set cloud placement;^n-1 = bottom of the skybox, 1 = top of the skybox"
setdesc "cloudscale" "controls the scale of the cloud layer" "value"
setdesc "cloudscrollx" "controls the movement speed of the cloud layer on the x axis" "value"
setdesc "cloudscrolly" "controls the movement speed of the cloud layer on the y axis" "value"
setdesc "cloudlayercolour" "controls the colour of the cloud layer" "hexcolour"
setdesc "cloudfade" "controls how the cloud layer fades around the edges" "value"
setdesc "dropwaypoints" "determines if waypoints are dropped by players in game, defaults to 1;^n0 = no waypoints are dropped, 1 = limited number of waypoints are dropped" "value"
setdesc "showwaypoints" "toggles the visibility of the path that connects waypoints, waypoints are always visible if they are being dropped" "value"
setdesc "savewaypoints" "saves a .wpt file containing the current maps waypoints, if no argument is given it uses the current map's name" "[name]"
setdesc "loadwaypoints" "loads a .wpt file containing waypoints, if no argument is given it loads a waypoint file matching the current map's name" "[name]"
setdesc "delselwaypoints" "delete the waypoints in the currently selected area"

setdesc "followaiming" "determines aim direction when following a player" "[aim in thirdperson] [aim in first person]"
setdesc "spectvfirstperson" "determines aim direction of spectv;^n0 = aim in direction followed player is facing, 1 = aim in direction determined by spectv when dead, 2 = always aim in direction" "value"
setdesc "spectvthirdperson" "determines aim direction of spectv;^n0 = aim in direction followed player is facing, 1 = aim in direction determined by spectv when dead, 2 = always aim in direction" "value"
setdesc "previousmaps" "list of previously played maps"
setdesc "maphistory" "remember this many maps that can't be voted again if votelock is set" "value"
setdesc "intermmode" "determines camera style in intermission;^n0 = float, 1 = tv" "value"
setdesc "coopbalance" "in coop, bot team gets this many players for each human"
setdesc "coopmultibalance" "in multi-coop, each bot team gets this many players for each human"
// aliases and input
setdesc "setpersist" "toggles an alias as persistent, that is, determines if it will be added to config.cfg;^nbool: 0 = not persistent, 1 = persistent" "alias bool"
setdesc "local" "declares a set of aliases as local to the alias (function) it was declared in"
setdesc "alias" "defines a new alias (variable or command block);^n example: alias pi 3.14159265359^nis equivalent to: pi = 3.14159265359" "name contents"
setdesc "getalias" "looks up the contents of an alias;^nexample: echo (getalias dm)^nis equivalent to: echo $dm" "name"
setdesc "inputcommand" "prepares input to the command line;^ninit is the input string,^n[action] is an optional command to execute after inputcommand,^n[prompt] is an optional prompt to use next to the input,^n[icon] is an optional icon to use next to the input (example: ^"textures/icons/chat^"),^n[colour] is an optional color of icon,^n[flags] are optional command flags to pass {c = CF_COMPLETE, x = CF_EXECUTE, s = CF_COMPLETE|CF_EXECUTE (default)}" "init [action] [prompt] [icon] [colour] [flags]"
setdesc "setcomplete" "Enables (or disables) tab-completion of a command;^nname is the name of a command or alias,^n[bool] (1) enables completion of name (the dafault is 0, disabled)." "name [bool]"
setdesc "listcomplete" "Enables tab-completion of a command's first argument;^nname is a command or alias,^nlist is a list of valid arguments to be completed" "name list"
setdesc "playercomplete" "Enables tab-completion for players as argument of a command;^nname is a command or alias,^nremove can be omitted to add a completion or set to >0 to remove the completion" "name remove"
setdesc "complete" "Enables tab-completion for files as argument of a command;^nname is a command or alias,^n[path] is a directory to look for the files, note the path is not contained in the auto-completed argument,^nextension allows to pick only a certain file type, and will omit the extension when completing file names.^nexample: complete guifont config/fonts cfg" "name [path] [extension]"
//binds
setdesc "bind" "binds an action to a key. WARNING: This overrides existing binds for that key;^nkey is a key, for example KP1 or RETURN,^naction is a command to be executed when the key is pressed,^nexample: bind O [echo O was pressed ... ; onrelease [echo ... and released]]" "key action"
setdesc "editbind" "binds an edit mode action to a key. WARNING: This overrides existing edit binds for that key;^nkey is a key, for example KP1 or RETURN,^naction is a command to be executed when the key is pressed in edit mode." "key action"
setdesc "specbind" "binds a spectator mode action to a key. WARNING: This overrides existing spectator binds for that key;^nkey is a key, for example KP1 or RETURN,^naction is a command to be executed when the key is pressed in spectator mode." "key action"
setdesc "getbind" "returns the command associated with a given key bind;^nkey is a key, for example KP1 or RETURN." "key"
setdesc "geteditbind" "returns the command associated with a given key bind for edit mode;^nkey is a key, for example KP1 or RETURN." "key"
setdesc "getspecbind" "returns the command associated with a given key bind for spectator mode;^nkey is a key, for example KP1 or RETURN." "key"
setdesc "searchbinds" "finds key binds for a given action;^nthis is used by the dobindsearch alias" "action [formatting options]"
setdesc "searcheditbinds" "finds edit key binds for a given action;^nthis is used by the dobindsearch alias" "action [formatting options]"
setdesc "searchspecbinds" "finds spectator key binds for a given action;^nthis is used by the dobindsearch alias" "action [formatting options]"
setdesc "dobindsearch" "prints out a nicely formatted string with the key binds for a given action;^naction is the action to search for,^n[mode] can be edit or spec to search for the corresponding mode specific binds." "key [mode]"

setdesc "loop" "executes body with var incremented from 0 to count-1;^nexample: loop i 10 [ echo $i ]" "var count body"
setdesc "loopconcat" "returns a string with the result of the body concatenated with var incremented from 0 to count-1;^nexample: loopconcat i 10 [ result $i ]" "var count body"
setdesc "loopconcatword" "returns a string with the result of the body concatword-ed with var incremented from 0 to count-1;^nexample: loopconcatword i 10 [ result $i ]" "var count body"
setdesc "loopfiles" "executes body with var set to each file in directory with the given extension (^"^" for extension is all files);^nexample: loopfiles f data cfg [ echo $f ]" "var directory extension body"
setdesc "looplist" "executes body with var set to each item in list;^nexample: looplist i ^"this is a list^" [ echo $i ]" "var list body"
setdesc "loopwhile" "executes body with var incremented from 0 to count-1 while condition is true;^nexample: loopwhile i 10 [  $i 5 ] [ echo $i ]" "var count condition body"
setdesc "while" "executes body while cond is true;^nexample: i = 0; while [  $i 10 ] [ echo $i; i = (+ $i 1) ]" "<cond body"
//lists
setdesc "indexof" "returns the index in list of data;^nexample: indexof ^"this is a list^" list" "list data"
setdesc "listdel" "returns the list1 with all occurrences of each element in list2 removed, it is equivalent to set difference;^nexample: listdel ^"this list has duplicates^" ^"this duplicates^", will return ^"list has^"" "list1 list2"
setdesc "listfind" "returns the index in list where the body returns true, similar to looplist;^nexample: listfind i ^"this is a list^" [ result (= (strstr $i l) 0) ]" "var list body"
setdesc "listlen" "returns the length of the list;^nexample: listlen ^"this is a list^"" "list"
setdesc "listsplice" "returns a list where the elements between the start index and the end or for count elements is replaced with value;^nexample: listsplice ^"1 2 3 4 5 6^" insert 2 3" "list value start count"
setdesc "prettylist" "returns a recombined list with a comma placed between each list element and conjunctor placed between the last two elements (in addition to the comma);^nexample: prettylist ^"1 2 3 4^" and" "list conjunctor"
setdesc "shrinklist" "returns a list of all element that exists in both list1 and list2;^nif there are no results and failover is 1 or 2, the list that failover points to is returned,^nwithout failover, shrinklist is equivalent to set symmetric difference;^nexample: shrinklist ^"this is a list^" ^"this is another list^", will return ^"this is list^"" "list1 list2 [failover]"
setdesc "sublist" "returns a sublist of list starting at start and ending at the end or for count elements;^nexample: sublist ^"this is a list^" 1 2" "list start [count]"
//logic
setdesc "&" "returns the bit-wise AND of int1 and int2" "int1 int2"
setdesc "&~" "returns the bit-wise NOT of the bit-wise AND of int1 and int2" "int1 int2"
setdesc "<<" "returns <int1 left shifted int2 times" "int1 int2"
setdesc ">>" "returns int1 right shifted int2 times" "int1 int2"
setdesc "^^" "returns the bit-wise XOR of int1 and int2" "int1 int2"
setdesc "^^~" "returns the bit-wise NOT of the bit-wise XOR of int1 and int2" "int1 int2"
setdesc "|" "returns the bit-wise OR of int1 and int2" "int1 int2"
setdesc "|~" "returns the bit-wise NOT of the bit-wise OR of int1 and int2" "int1 int2"
setdesc "~" "returns the bit-wise NOT of int" "int"
setdesc "!" "returns the logical not of condition" "condition"
setdesc "&&" "returns the logical and of all given conditions" "condition..."
setdesc "?" "returns true_body when condition is true, otherwise false_body" "condition true_body false_body"
setdesc "||" "returns the logical or of all given conditions" "condition..."
setdesc "!=" "returns true when int1 is not equal to int2" "int1 int2"
setdesc "!=f" "returns true when float1 is not equal to float2" "float1 float2"
setdesc "!=s" "returns true when string1 is not equal to string2 on the ascii table" "string1 string2"
setdesc "<=" "returns true when int1 is less than or equal to int2" "int1 int2"
setdesc "<=f" "returns true when float1 is less than or equal to float2" "float1 float2"
setdesc "<=s" "returns true when <string1 is less than or equal to string2 on the ascii table" "string1 string2"
setdesc "<" "returns true when <int1 is less than int2" "int1 int2"
setdesc "<f" "returns true when <float1 is less than float2" "float1 float2"
setdesc "<s" "returns true when <string1 is less than string2 on the ascii table" "string1 string2"
setdesc "=" "returns true when int1 is equal to int2" "int1 int2"
setdesc "=f" "returns true when float1 is equal to float2" "float1 float2"
setdesc "=s" "returns true when string1 is equal to string2 on the ascii table" "string1 string2"
setdesc ">=" "returns true when int1 is greater than or equal to int2" "int1 int2"
setdesc ">=f" "returns true when float1 is greater than or equal to float2" "float1 float2"
setdesc ">=s" "returns true when string1 is greater than or equal to string2 on the ascii table" "string1 string2"
setdesc ">" "returns true when int1 is greater than int2" "int1 int2"
setdesc ">f" "returns true when float1 is greater than float2" "float1 float2"
setdesc ">s" "returns true when string1 is greater than string2 on the ascii table" "string1 string2"
setdesc "max" "returns the maximum integer value;^nexample: max 1 3 -9" "integer..."
setdesc "maxf" "returns the maximum float value;^nexample: maxf 1.1, 2.9, -9.5" "float..."
setdesc "min" "returns the minimum integer value;^nexample: min 1 3 -9" "integer..."
setdesc "minf" "returns the minimum float value;^nexample: minf 1.1, 2.9, -9.5" "float..."

setdesc "strcasecmp" "returns true when string1 is equal to string2 ignoring case;^nexample: strcasecmp ^"str^" ^"StR^"" "string1 string2"
setdesc "~=s" "returns true when string1 is equal to string2 ignoring case;^nexample: ~=s ^"str^" ^"StR^"" "string1 string2"
setdesc "strcmp" "returns true when string1 is equal to string2, equivalent to =s;^nexample: strcmp ^"str^" ^"str^"" "string1 string2"
setdesc "=s" "returns true when string1 is equal to string2, equivalent to =s;^nexample: =s ^"str^" ^"str^"" "string1 string2"
setdesc "strlen" "returns the length of string;^nexample: strlen ^"four^"" "string"
setdesc "strncasecmp" "returns true when the first count characters of string1 and string2 are equal ignoring case;^nexample: strncasecmp ^"str^" ^"StRiNg^" 3" "string1 string2 count"
setdesc "~=sn" "returns true when the first count characters of string1 and string2 are equal ignoring case;^nexample: ~=sn ^"str^" ^"StRiNg^" 3" "string1 string2 count"
setdesc "strncmp" "returns true when the first count characters of string1 and string2 are equal;^nexample: strncmp ^"str^" ^"string^" 3" "string1 string2 count"
setdesc "=sn" "returns true when the first count characters of string1 and string2 are equal;^nexample: =sn ^"str^" ^"string^" 3" "string1 string2 count"
setdesc "strreplace" "returns string with all occurrences of search replaced with replace;^nexample: strreplace ^"misspelled sring^" ^"sring^" ^"string^"" "string search replace"
setdesc "strstr" "returns the index of search in string;^nexample: strstr ^"long string^" ^"str^"" "string search"
setdesc "substring" "returns a substring of string starting at start and continuing to the end or for count characters;^nexample: substring ^"string^" 2 3" "string start [count]"
setdesc "concat" "returns all values concatenated with a space between each argument;^nexample: concat hello (getname)" "value..."
setdesc "concatword" "returns all values concatenated without a space between each argument;^nexample: concatword squished string" "value..."
setdesc "clearsleep" "removes all pending sleeps, if clearworlds is set, it will only clear sleeps generated in a map's config file;^nexample: clearsleep" "[clearworlds]"
setdesc "do" "executes body;^nexample: do [ echo hi ]" "body"
setdesc "caseif" "executes a list of conditions and body counterparts, stops evaluating if condition is met;^n example: caseif (=s $var1 moo) [echo moo] (= $var2 woof) [echo woof] () [echo null]"  "condition1 body1 condition2 body2 ..."
setdesc "doif" "executes a list of conditions and body counterparts, continues evaluating even if condition is met;^n example: doif (=s $var1 moo) [echo moo] (= $var2 woof) [echo woof] () [echo null]"  "condition1 body1 condition2 body2 ..."
setdesc "format" "returns a formatted string with all %1 - %9 replaced with the respective value argument, %% inserts a % sign;^nexample: format ^"Hello, %1, welcome to Red Eclipse v. %2^" (getname) $version" "format_string value..."
setdesc "if" "execute true_body when condition is true, otherwise executes false_body;^nexample: if (<= $var 5) [ echo less than or equal to 5 ] [ echo greater than 5 ]" "condition true_body false_body"
setdesc "push" "pushes value into var's stack and executes body then pops value off of var so that var is untouched after execution of body;^nexample: var = 5; push var 10 [ echo $var ]; echo $var" "var value body"
setdesc "result" "sets the return value for the currently executing code to value, note that this does not stop the code execution like return would;^nexample: result 1" "value"
setdesc "rnd" "returns a random number between 0 or min and max;^nexample: rnd 50 25" "max [min]"
setdesc "sleep" "executes body after waiting milliseconds;^nexample: sleep 2000 [ echo waited 2 seconds ]" "milliseconds body"
setdesc "at" "returns the element at index in list, subsequent indexes are at'd with the previous result;^nexample: at [this has a [nested list]] 3 1" "list index [nested_index...]"
setdesc "filter" "filters a string by stripping of any or all of the following: newlines, color, and whitespace, each of these values are boolean, and true by default if omitted;^n[newlines] - if true, replaces newline characters with spaces,^n[color] - if true, any color formatting will be removed,^n[whitespace] - if true, whitespace is kept; if false, whitespace is removed" "string [newlines] [color] [whitespace]"
setdesc "goto" "jumps the spectator camera to the position of the specified client" "name/cn"
setdesc "hexcolour" "converts a decimal color value to a ^"pretty-printed^" hexadecimal color value;^nexample: (hexcolour 342344) will give 0x093548" "color"
setdesc "precf" "returns the value float truncated to accuracy number of decimals;^nexample: (precf 0.14986 2) will give 0.14" "float accuracy"
setdesc "writevars" "writes the current server's variables to a config file named file;^nif [all] is true, every variable will be written with default values commented out; if false, only changed variables will be written (default: false)^nif [sv_] is true, variables will be prefixed with ^"sv_^" (default: false)" "file [all] [sv_]"
setdesc "case"  "executes the first body where the corresponding test_value is equivalent to integer using integer comparison;^nfor the 'default' case (always true), use () for the test_value, has a limit of 12 conditions,^nexample: case (rnd 3) 0 [ echo 0 ] 1 [ echo 1 ] () [ echo default ]" "integer [test_value body] [test_value body] [...]"
setdesc "casef" "executes the first body where the corresponding test_value is equivalent to float using float comparison;^nfor the 'default' case (always true) use () for the test_value, has a limit of 12 conditions,^nexample: case (+f (rnd 3) .1) 0.1 [ echo 0.1 ] 1.1 [ echo 1.1 ] () [ echo default ]" "float [test_value body] [test_value body] [...]"
setdesc "cases" "executes the first body where the corresponding test_value is equivalent to string using string comparison;^nfor the 'default' case (always true) use () for the test_value, has a limit of 12 conditions,^nexample: case (substring ^"abc^" (rnd 3) 1) a [ echo a ] b [ echo b ] () [ echo default ]" "string [test_value body] [test_value body] [...]"
setdesc "cond"  "executes the first body where the corresponding condition is true, has a limit of 12 conditions;^nexample: i = (rnd 3); cond [ = $i 0 ] [ echo 0 ] [ = $i 1 ] [ echo 1 ] 1 [ echo default ]" "[condition body] [condition body] [...]"
setdesc "getvarmin" "returns the minimum value of varname, a built-in integer variable;^nexample: getvarmin firstpersonfov" "varname"
setdesc "getvarmax" "returns the maximum value of varname, a built-in integer variable;^nexample: getvarmax firstpersonfov" "varname"
setdesc "getfvarmin" "returns the minimum value of varname, a built-in float variable;^nexample: getfvarmin movespeed" "varname"
setdesc "getfvarmax" "returns the maximum value of varname, a built-in float variable;^nexample: getfvarmax movespeed" "varname"
setdesc "isonline" "returns 1 if you are online and 0 if not"
setdesc "escape" "returns a quoted string with all newline, tab, form feed, ^^, and ^" characters converted to the cubescript escape sequence (^^n, ^^t, ^^f, ^^^^, ^^^");^nexample: escape [line1^^nline2]" "text"
setdesc "unescape" "returns a string with all cubescript escape sequences (^^n, ^^t, ^^f, ^^^^, ^^^") converted back into newline, tab, form feed, ^^, and ^" respectively;^nexample: unescape [line1^^^^nline2]" "text"
//mathematic
setdesc "*" "returns all arguments multiplied together as integers" "int..."
setdesc "*f" "returns all arguments multiplied together as floats" "float..."
setdesc "+" "returns all arguments added together as integers" "int..."
setdesc "+f" "returns all arguments added together as floats" "float..."
setdesc "-" "returns all other arguments subtracted from the first argument as integers" "int..."
setdesc "-f" "returns all other arguments subtracted from the first argument as floats" "float..."
setdesc "div" "returns all other arguments divided from the first argument as integers" "int..."
setdesc "divf" "returns all other arguments divided from the first argument as floats" "float..."
setdesc "mod" "returns the modulus of int1 and int2 (that is, the remainder of int1/int2)" "int1 int2"
setdesc "modf" "returns the modulus of float1 and float2 (that is, the remainder of float1/float2)" "float1 float2"
setdesc "cos" "returns the cosine of float;^nexample: cos 3.1415" "float"
setdesc "sin" "returns the sine of float;^nexample: sin 3.1415" "float"
setdesc "tan" "returns the tangent of float;^nexample: tan 3.1415" "float"
setdesc "acos" "returns the arc-cosine of float;^nexample: acos 1" "float"
setdesc "asin" "returns the arc-sine of float;^nexample: asin 1" "float"
setdesc "atan" "returns the arc-tangent of float;^nexample: atan 1" "float"
setdesc "abs" "returns the absolute power of integer;^nexample: abs -5" "integer"
setdesc "absf" "returns the absolute power of float;^nexample: absf -8.5" "float"
setdesc "exp" "returns e (2.71828) raised to the float power;^nexample: exp 5.6" "float"
setdesc "pow" "returns base raised to the power of exponent;^nexample: pow 2.1 8.1" "base exponent"
setdesc "sqrt" "returns the square root of float;^nexample: sqrt 4" "float"
setdesc "log10" "return the logarithm of float with base 10;^nexample: log10 1000" "float"
setdesc "log2" "return the logarithm of float with base 2;^nexample: log2 8" "float"
setdesc "loge" "return the logarithm of float with base e;^nexample: loge 20.08" "float"

setdesc "sortlist" "returns a sorted list (quicksort) based on the result of body applied onto list;^n if body returns true the two elements varname_1 and varname_2 will be swapped, unchanged otherwise,^nexample: sortlist ^"cat ape bear boar^" a b [s $a $b], will return ^"ape bear boar cat^" (<s is ascii-alphabetic comparison)" "<list varname_1 varname_2 body"
setdesc "stripcolors" "returns the string without any colors;^nexample: stripcolors ^"^^frhello ^^f[6252287]^"" "string"
setdesc "addlocalop" "elevates the privilege of a user to a specified level locally;^nthis allows server administrators to ^"upgrade^" the access of people as they identify, on that particular server,^nuser_handle is the authkey handle of the user,^nflag is the privilege level {a = administrator m = moderator o = operator s = supporter}" "user_handle flag"
setdesc "resetlocalop" "removes all temporary elevated local privileges;^nthis allows server administrators to reset the access given by addlocalop for all users, on that particular server"
setdesc "ircaddchan" "joins a channel on a given IRC instance with automatic rejoin;^nname - name of the IRC instance,^nchannel - channel to join,^n[friendly] - optional friendly name of channel,^n[passkey] - optional passkey required for mode +k channels,^n[relay] - optional relay level (verbosity of output)" "name channel [friendly] [passkey] [relay]"
setdesc "ircaddclient" "creates an IRC instance of type 'client';^nname - name of the created IRC instance,^nhost - host to connect to,^nport - port of host to connect on,^nnick - nickname to use for the connection,^n[ip] - optional address to bind to (leave blank for any),^n[passkey] - optional password required to connect to host" "name host port nick [ip] [passkey]"
setdesc "ircaddrelay" "creates an IRC instance of type 'relay';^nname - name of the created IRC instance,^nhost - host to connect to,^nport - port of host to connect on,^nnick - nickname to use for the connection,^n[ip] - optional address to bind to (leave blank for any),^n[passkey] - optional password required to connect to host" "name host port nick [ip] [passkey]"
setdesc "ircjoinchan" "joins a channel on a given IRC instance without automatic rejoin;^nname - name of the IRC instance,^nchannel - channel to join,^n[friendly] - optional friendly name of channel,^n[passkey] - optional passkey required for mode +k channels^n[relay] - optional relay level (verbosity of output)" "name channel [friendly] [passkey] [relay]"
setdesc "ircfilter" "sets how IRC messages are filtered;^n0 = send string as is, color escapes not converted, other escapes not filtered,^n1 = convert Cube2-style color escapes to IRC color escapes,^n2 = filter out all Cube2-style escapes" "value"
setdesc "ircbind" "sets the address that an IRC instance binds to;^nwhen used without [ip], returns the address that the IRC instance 'name' is currently bound to,^nname - name of the IRC instance,^n[ip] - optional ip address for name to bind to" "name [ip]"
setdesc "ircconnect" "attempts to establish a connection to the IRC instance 'name'" "name"
setdesc "ircconns" "returns the number of active IRC connections"
setdesc "ircfriendlychan" "sets the friendly name of an IRC channel;^nif the [friendly] parameter is not specified, the current friendly name of the channel is returned,^nname - name of an IRC instance,^nchannel - the IRC channel,^n[friendly] - optional new friendly name to use" "name channel [friendly]"
setdesc "ircnick" "sets the nickname of an IRC instance;^nif the [nick] parameter is not specified, the current nickname is returned,^nname - name of the IRC instance,^n[nick] - optional new nickname" "name [nick]"
setdesc "ircident" "sets the ident of an IRC instance;^nif the [ident] parameter is not specified, the current ident is returned,^nname - name of the IRC instance,^n[ident] - optional new ident" "name [ident]"
setdesc "ircauthcommand" "run command to auth when the IRC instance name is connected" "name [command]"
setdesc "ircpass" "sets the server passkey used by an IRC instance;^nif the [passkey] parameter is not specified, ^"set^" or ^"not set^" will be returned accordingly,^nname - name of the IRC instance,^n[passkey] - optional new passkey" "name [passkey]"
setdesc "ircpasschan" "sets the passkey for a channel on an IRC instance;^nif the [passkey] parameter is not specified, ^"set^" or ^"not set^" will be returned accordingly,^nname - name of the IRC instance^nchannel - the IRC channel,^n[passkey] - optional new passkey" "name [passkey]"
setdesc "ircrelaychan" "sets the relay level for a channel on an IRC instance;^nif the [relay] parameter is not specified, the current relay level will be returned,^nname - name of the IRC instance,^nchannel - the IRC channel,^n[relay] - optional new relay level (verbosity of output)" "name channel [relay]"
setdesc "ircport" "sets the server port used by an IRC instance;^nif the [port] parameter is not specified, the current server port is returned,^nname - name of an IRC instance,^n[port] - optional new port" "name [port]"
setdesc "ircserv" "sets the host to connect to for a given IRC instance;^nif the [host] parameter is not specified, the current host is returned,^nname - name of an IRC instance,^n[host] - optional new hostname" "name [host]"
setdesc "ircauth" "sends a message to a specified target when succefully connected to an an IRC server;^ncan be used for setting up automatic authentication,^nif only name is specified, [target] is returned along with ^"set^" or ^"not set^" for [message],^nname - name of the IRC instance,^n[target] - target for the message (user, service, channel),^n[message] - message sent to [target],^nexample: ircauth myrelay NickServ ^"IDENTIFY password^"" "name [target] [message]"
setdesc "botoffset" "increases or decreases the amount of bots starting from the numplayers value of the current map" "value"
setdesc "mapcomplete" "enables map completion for a given command or alias;^nthis enables tab-completion for the first argument of an already existing command or alias,^nthe completion uses files that ends with 'mpz' in the 'maps' folders of the game's homedir, and its data dir(s)" "command"
setdesc "map" "requests a map change to a given map, with no change of mode or mutators;^ndepending on privileges, this will force or vote for the map change" "map"
//modes
setdesc "gamemode" "returns the current game mode; 0 = demo, 1 = edit, 2 = dm, 3 = ctf, 4 = dac, 5 = bb, 6 = race"
setdesc "mode" "sets the mode and mutator values for the next map change request;^nmode sets the mode type,^nmuts sets the mutators according to a bitwise sum of mutator values,^nconveniently set using $modeidx* vars and sums of $mutsbit* vars,^nexample: mode $modeidxdeathmatch (+ $mutsbitinstagib $mutsbitmedieval)" "mode muts"
setdesc "start" "requests a map change to a given map with a specific mode and mutators;^ndepending on privileges, this will force or vote for the map change,^nmode sets the mode type,^nmuts sets the mutators according to a bitwise sum of mutator values,^nconveniently set using $modeidx* vars and sums of $mutsbit* vars,^nexample: start bath $modeidxdeathmatch (+ $mutsbitinstagib $mutsbitmedieval)" "map mode muts"
setdesc "edit" "starts editing on a random map. specifying a file name will create a new map file on a blank map canvas" "map"
setdesc "demo" "starts playback of a given demo" "demo"
setdesc "deathmatch" "requests a map change to deathmatch on a given map;^n[muts] optionally adds extra mutators according to bitwise mutator values, conveniently set using a sum of $mutsbit* vars,^nexample: deathmatch bath (+ $mutsbitinstagib $mutsbitmedieval)" "map [muts]"
setdesc "dm" "requests a map change to deathmatch on a given map;^n[muts] optionally adds extra mutators according to bitwise mutator values, conveniently set using a sum of $mutsbit* vars,^nexample: dm bath (+ $mutsbitinstagib $mutsbitmedieval)" "map [muts]"
setdesc "teamdm" "requests a map change to team deathmatch on a given map;^n[muts] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: teamdm bath (+ $mutsbitinstagib $mutsbitmedieval)" "map [muts]"
setdesc "tdm" "requests a map change to team deathmatch on a given map;^n[muts] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: tdm bath (+ $mutsbitinstagib $mutsbitmedieval)" "map [muts]"
setdesc "multidm" "requests a map change to multi deathmatch on a given map;^n[muts] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: multidm bath (+ $mutsbitinstagib $mutsbitmedieval)" "map [muts]"
setdesc "mdm" "requests a map change to multi deathmatch on a given map;^n[muts] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: mdm bath (+ $mutsbitinstagib $mutsbitmedieval)" "map [muts]"
setdesc "coop" "requests a map change to coop deathmatch on a given map;^n[muts] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: coop bath (+ $mutsbitinstagib $mutsbitmedieval)" "map [muts]"
setdesc "cdm" "requests a map change to coop deathmatch on a given map;^n[muts] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: cdm bath (+ $mutsbitinstagib $mutsbitmedieval)" "map [muts]"
setdesc "instagib" "requests a map change to instagib deathmatch on a given map;^n[muts] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: instagib bath (+ $mutsbitduel $mutsbitmedieval)" "map [muts]"
setdesc "insta" "requests a map change to instagib deathmatch on a given map;^n[muts] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: insta bath (+ $mutsbitduel $mutsbitmedieval)" "map [muts]"
setdesc "medieval" "requests a map change to medieval deathmatch on a given map;^n[muts] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: medieval bath (+ $mutsbitinstagib $mutsbitfreestyle)" "map [muts]"
setdesc "kaboom" "requests a map change to kaboom deathmatch on a given map;^n[muts] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: kaboom bath (+ $mutsbitinstagib $mutsbitfreestyle)" "map [muts]"
setdesc "duel" "requests a map change to duel deathmatch on a given map;^n[muts] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: duel bath (+ $mutsbitinstagib $mutsbitmedieval)" "map [muts]"
setdesc "survivor" "requests a map change to survivor deathmatch on a given map;^n[muts] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: survivor bath (+ $mutsbitinstagib $mutsbitmedieval)" "map [muts]"
setdesc "lms" "requests a map change to survivor deathmatch (last man standing) on a given map;^n[muts] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: lms bath (+ $mutsbitinstagib $mutsbitmedieval)" "map [muts]"
setdesc "classic" "requests a map change to classic deathmatch on a given map;^n[muts] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: classic bath (+ $mutsbitinstagib $mutsbitduel)" "map [muts]"
setdesc "capture" "requests a map change to capture-the-flag on a given map;^n[muts] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: capture bath (+ $mutsbitinstagib $mutsbitmedieval)" "map [muts]"
setdesc "ctf" "requests a map change to capture-the-flag on a given map;^n[muts] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: ctf bath (+ $mutsbitinstagib $mutsbitmedieval)" "map [muts]"
setdesc "quickcapture" "requests a map change to quick capture-the-flag on a given map;^n[muts] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: quickcapture bath (+ $mutsbitinstagib $mutsbitmedieval)" "map [muts]"
setdesc "defendcapture" "requests a map change to defend capture-the-flag on a given map;^n[muts] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: defendcapture bath (+ $mutsbitinstagib $mutsbitmedieval)" "map [muts]"
setdesc "protectcapture" "requests a map change to protect capture-the-flag on a given map;^n[muts] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: protectcapture bath (+ $mutsbitinstagib $mutsbitmedieval)" "map [muts]"
setdesc "defend" "requests a map change to defend-and-control on a given map;^n[muts] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: defend bath (+ $mutsbitinstagib $mutsbitmedieval)" "map [muts]"
setdesc "dac" "requests a map change to defend-and-control on a given map;^n[muts] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: dac bath (+ $mutsbitinstagib $mutsbitmedieval)" "map [muts]"
setdesc "dnc" "requests a map change to defend-and-control on a given map;^n[muts] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: dac bath (+ $mutsbitinstagib $mutsbitmedieval)" "map [muts]"
setdesc "quickdefend" "requests a map change to quick defend-and-control on a given map;^n[muts] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: quickdefend bath (+ $mutsbitinstagib $mutsbitmedieval)" "map [muts]"
setdesc "kingdefend" "requests a map change to king defend-and-control on a given map;^n[muts] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: kingdefend bath (+ $mutsbitinstagib $mutsbitmedieval)" "map [muts]"
setdesc "koth" "requests a map change to king defend-and-control (king of the hill) on a given map;^n[muts] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: koth bath (+ $mutsbitinstagib $mutsbitmedieval)" "map [muts]"
setdesc "bomber" "requests a map change to bomber-ball on a given map;^n[muts] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: bomber futuresport (+ $mutsbitinstagib $mutsbitmedieval)" "map [muts]"
setdesc "bb" "requests a map change to bomber-ball on a given map;^n[muts] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: bb futuresport (+ $mutsbitinstagib $mutsbitmedieval)" "map [muts]"
setdesc "holdbomber" "requests a map change to hold bomber-ball on a given map;^n[muts] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: holdbomber bath (+ $mutsbitinstagib $mutsbitmedieval)" "map [muts]"
setdesc "basketbomber" "requests a map change to basket bomber-ball on a given map;^n[muts] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: basketbomber bath (+ $mutsbitinstagib $mutsbitmedieval)" "map [muts]"
setdesc "attackbomber" "requests a map change to attack bomber-ball on a given map;^n[muts] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: attackbomber bath (+ $mutsbitinstagib $mutsbitmedieval)" "map [muts]"
setdesc "race" "requests a map change to race on a given map;^n[muts] optionally adds extra mutators according to bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: race purge (+ $mutsbitfreestyle $mutsbitmedieval)" "map [muts]"
setdesc "timedrace" "requests a map change to timed race on a given map;^n[muts] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: timedrace purge (+ $mutsbitffa $mutsbitfreestyle)" "map [muts]"
setdesc "trial" "requests a map change to timed race on a given map;^n[muts] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: trial purge (+ $mutsbitffa $mutsbitfreestyle)" "map [muts]"
setdesc "endurancerace" "requests a map change to endurance race on a given map;^n[muts] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: endurancerace purge (+ $mutsbitffa $mutsbitfreestyle)" "map [muts]"
setdesc "gauntletrace" "requests a map change to gauntlet race on a given map;^n[muts] optionally adds extra mutators according to a bitwise mutator values,^nconveniently set using a sum of $mutsbit* vars,^nexample: gauntletrace purge (+ $mutsbitffa $mutsbitfreestyle)" "map [muts]"

setdesc "writevarsinfo" "writes raw information about all existing vars, commands and aliases to a file;^nfor each item the following fields are printed: NAME TYPE FLAGS ARGS VALTYPE VALUE MIN MAX DESC USAGE,^nfields are separated by tabs, and empty if nonexistent" "file"
setdesc "simpleitems" "sets how items are shown in the level;^n0 = items are models, 1 = items are icons, 2 = items are off and only halos appear" "level"
setdesc "simpleitemsize" "sets the size of simple items" "size"
setdesc "simpleitemblend" "sets the blend level of simple items" "blend"
setdesc "simpleitemhalo" "adjusts the halo blend when displaying simple items as icon" "blend"
setdesc "autospecdelay" "determines the delay after player joins spectators after being fragged" "milliseconds"
setdesc "bomberlockondelay" "determines the amount of time needed to hold throw button to achieve assisted pass to another team member" "milliseconds"
setdesc "capturecarryspeed" "multiplier for the movement speed of flag-carrying players;^nacts as an added multiplier on top of the normal movespeed multiplier" "value"
setdesc "capturepickupdelay" "time a player needs to wait to be able to pick up a flag again after losing it" "milliseconds"
setdesc "coopskillmax" "determines the maximum skill level a bot can have in coop" "value"
setdesc "coopskillmin" "determines the minimum skill level a bot can have in coop" "value"
setdesc "fragbonus" "determines the amount of points a player gets for each frag" "value"
setdesc "enemybonus" "determines the amount of points a player gets for frags against neutral enemies in onslaught" "value"
setdesc "lasthitbonus" "determines the amount of points a player gets for last hits in gladiator" "value"
setdesc "headshotpoints" "determines the amount of bonus points a player gets when a frag is caused by a headshot" "value"
setdesc "multikillpoints" "determines the amount of bonus points a player gets for a double, triple, or multi kill" "value"
setdesc "multikillbonus" "determines if multikillpoints should be multiplied by 2, 3, or 4 as appropriate" "value"
setdesc "spreepoints" "determines the amount of points a player gets for achieving each level of killing spree for the first time" "value"
setdesc "spreebreaker" "determines the amount of points a player gets for ending an opponent's killing spree" "value"
setdesc "dominatepoints" "determines the amount of points a player gets when he achieves domination on another player" "value"
setdesc "revengepoints" "determines the amount of points a player gets when he gets revenge against a dominating player" "value"
setdesc "firstbloodpoints" "determines the amount of points a player gets when he makes the first kill of a match" "value"
setdesc "mapbalance" "determines if teams are switched on asymmetrical maps after half of the time is over;^n0 = no balance, 1 = balance only in ctf/dac/bb, 2 = balance in all modes" "value"
setdesc "teamkillban" "automatically ban player when warned this many times for teamkill" "value"
setdesc "teamkillkick" "automatically kick player when warned this many times for teamkill" "value"
setdesc "teamkillpenalty" "subtract this*fragbonus from the players points when teamkilling" "value"
setdesc "teamkillrestore" "restore the team score as if the teamkiller was never there if the point loss of the team was greater than this" "value"
setdesc "teamkilltime" "time threshold in which teamkills are counted" "minutes"
setdesc "teamkillwarn" "the limit of teamkills after which the player receives a warning" "value"
setdesc "waitforplayers" "wait this long for players to load the map" "milliseconds"
//talking
setdesc "saycommand" "write a chat message or command but waits for your affirmation to send it" "text"
setdesc "say" "send a message to the global chat" "text"
setdesc "me" "send a message to the global chat in the form of an action^nex: * foobar demonstrates something" "text"
setdesc "sayteam" "send a message to the team chat" "text"
setdesc "meteam" "send a message to the team chat in the form of an action^nex: * foobar (to team ...) demonstrates something" "text"
setdesc "whisper" "send a message directly to another player on the server^n^frnote: messages are ^fRnot ^frprivate and are visible in demos" "name/cn text"
setdesc "mewhisper" "send a message directly to another player on the server in the form of an action^nex: * foobar (whispers to barfoo) demonstrates something^n^frnote: messages are ^fRnot ^frprivate and are visible in demos" "name/cn text"

//weapons
looplist w $weapname [
    setdesc (concatword $w ammoadd) "the amount added when picking up the weapon or reloading it" "value"
    setdesc (concatword $w ammomax) "the maximum amount the clip of this weapon can hold, can never be higher than default" "value"
    setdesc (concatword $w delayreload) "the time it takes for the weapon to reload one 'add' unit" "milliseconds"
    setdesc (concatword $w laser) "determines if this weapon has a laser pointer which is projected to the point where the player is aiming" "value"
    setdesc (concatword $w frequency) "determines the multiplier of itemspawntime in which items of this type respawn in" "value"
    setdesc (concatword $w colour) "determines the weapon main colour;^naffects the light around the weapon, the ammo and the icon in the weaponlist" "colour"
    setdesc (concatword $w modes) "determines the modes in which this weapon is allowed or disallowed;^nconveniently set as a sum of $modebit* vars,^npositive sum: allow this weapon if one of the declared modes is selected,^nnegative sum: disallow this weapon if one if the declared modes is selected" "sum"
    setdesc (concatword $w muts) "determines the mutators in which this weapon is allowed or disallowed;^nconveniently set as a sum of $mutsbit* vars,^npositive sum: allow this weapon if one of the declared mutators is selected,^nnegative sum: disallow this weapon if one of the declared mutators is selected" "sum"

    loop n 2 [
        m = (+ $n 1)
        setdesc (concatword $w ammosub $m) "the amount taken from the clip for each firing action, set to zero for unlimited ammo" "value"
        setdesc (concatword $w delayattack $m) "the time it takes after each firing action for the weapon to be ready again" "milliseconds"
        setdesc (concatword $w damage $m) "the amount of damage a projectile from each firing action does" "value"
        setdesc (concatword $w speed $m) "the speed of a projectile from each firing action" "value"
        setdesc (concatword $w cooktime $m) "when more than zero, determines that the weapon can be 'cooked' this long before firing" "value"
        setdesc (concatword $w time $m) "the maximum lifetime of a projectile for each firing action" "milliseconds"
        setdesc (concatword $w guideddelay $m) "when more than zero, projectiles from this weapon will delay guided settings by this long" "milliseconds"
        setdesc (concatword $w escapedelay $m) "when more than zero, projectiles from this weapon will not be able to hurt its owner for this long" "milliseconds"
        setdesc (concatword $w explode $m) "determines the explosion radius for a particle of this firing action" "value"
        setdesc (concatword $w rays $m) "the amount of projectiles spawned from one shot of each firing action" "value"
        setdesc (concatword $w spread $m) "determines the amount a projectile from each firing action skews off-center" "value"
        setdesc (concatword $w spreadz $m) "when zero, keeps spread projectiles aligned horizontally, else divide the z axis this much" "value"
        setdesc (concatword $w aiskew $m) "determines 'added stupidity' for each weapon for AI counterparts" "value"
        setdesc (concatword $w fragweap $m) "when projectiles from this firing action are destroyed, create projectiles from this kind of weapon (+12 = alt fire for the weapon)" "value"
        setdesc (concatword $w flakdamage $m) "flak of this type deals this much damage" "value"
        setdesc (concatword $w fragrays $m) "when creating flak, create this many projectiles for it" "value"
        setdesc (concatword $w fragtime $m) "flak projectiles from this weapon last this long" "milliseconds"
        setdesc (concatword $w fragspeed $m) "flak projectiles from this weapon start with this much speed (may be influenced by fragspread/fragskew and fragrel)" "value"
        setdesc (concatword $w collide $m) "determines collision properties for a projectile from each firing action (bitwise OR)" "COLLIDE_TRACE COLLIDE_PROJ COLLIDE_OWNER IMPACT_GEOM IMPACT_PLAYER IMPACT_SHOTS BOUNCE_GEOM BOUNCE_PLAYER BOUNCE_SHOTS DRILL_GEOM DRILL_PLAYER DRILL_SHOTS STICK_GEOM STICK_PLAYER COLLIDE_HITSCAN"
        setdesc (concatword $w extinguish $m) "determines if a projectile from each firing action is extinguished by water" "value"
        setdesc (concatword $w cooked $m) "determines cooking style for a projectile" "[more damage] [less damage] [longer lifetime] [shorter lifetime] [faster speed] [slower speed] [extra rays] [zoom view] [keep zoom view]"
        setdesc (concatword $w guided $m) "determines guided style for a projectile, 0 = off, 1 = follow crosshair direction, 2 = home crosshair target (+1 only first target), 4 = home projectile target (+1 only first target), 6 = direct toward first crosshair direction" "value"
        setdesc (concatword $w radial $m) "determines the time between ticks of ^"continuous^" radial damage, starts counting from first ^"radiation^"" "milliseconds"

        setdesc (concatword $w residual $m) "determines if a projectile from each firing action has a residual effect" "burn bleed shock"
        setdesc (concatword $w residualundo $m) "determines if a projectile from each firing action will extinguish a residual effect" "burn bleed shock"
        setdesc (concatword $w fullauto $m) "determines if each firing action is fully automatic (click-and-hold) or not (click-and-click)" "bool"
        setdesc (concatword $w taperin $m) "determines the fraction of the lifetime from the start until the projectile reaches its full size" "value"
        setdesc (concatword $w taperout $m) "determines the fraction of the lifetime from the end where the projectile size ^"fades out^"" "value"
        setdesc (concatword $w elasticity $m) "multiplier of velocity for a projectile of each firing action when doing a bounce event" "value"
        setdesc (concatword $w reflectivity $m) "guard angle for a projectile of each firing action when doing a bounce event" "angle"
        setdesc (concatword $w relativity $m) "multiplier of player velocity added to a projectile of each firing action" "value"
        setdesc (concatword $w liquidcoast $m) "multiplier of velocity for a projectile of each firing action when in liquid" "value"
        setdesc (concatword $w weight $m) "relative weight for a projectile of each firing action" "value"
        setdesc (concatword $w radius $m) "determines the size for a projectile of each firing action" "value"
        setdesc (concatword $w kickpush $m) "determines the amount of pushback from shooting each firing action" "value"
        setdesc (concatword $w hitpush $m) "determines the amount of pushback from getting hit by this shot" "value"
        setdesc (concatword $w aidist $m) "determines the 'maximum distance' a weapon should be shot at, used by AI to determine weapon effectiveness ranges" "distance"
        setdesc (concatword $w partsize $m) "determines the maximum particle size of a projectile from each firing action" "value"
        setdesc (concatword $w partlen $m) "determines the maximum tape particle length of a projectile from each firing action" "value"
        setdesc (concatword $w speeddelta $m) "determines the amount by which each firing action is guided" "value"
        setdesc (concatword $w trace $m) "determines the multiplier of length to apply to traced weapons" "value"
        setdesc (concatword $w damagetorso $m) "determines the multiplier of damage for torso shots" "value"
        setdesc (concatword $w damagelegs $m) "determines the multiplier of damage for leg shots" "value"
        setdesc (concatword $w damagehead $m) "determines the multiplier of damage for head shots" "value"
        setdesc (concatword $w fragscale $m) "flak created by this firing action is scaled by this much" "value"
        setdesc (concatword $w fragspread $m) "flak created by this firing action spreads its direction randomly by this much if it doesn't impact a player" "value"
        setdesc (concatword $w fragrel $m) "flak created by this firing action retains this much of its parent relative momentum" "value"
        setdesc (concatword $w fragoffset $m) "flak created by this firing action is offset by this distance if it impacts a player before being created" "value"
        setdesc (concatword $w fragskew $m) "flak created by this firing action spreads its direction randomly by this much when it impacts a player" "value"
        setdesc (concatword $w wavepush $m) "determines the multiplier of explode radius this weapon pushes in" "value"
        setdesc (concatword $w explcol $m) "determines the colour of the explosion of a projectile from this weapon" "colour"
        setdesc (concatword $w flakcollide $m) "determines collision properties for flak of this type from each firing action (bitwise OR)" "COLLIDE_TRACE COLLIDE_PROJ COLLIDE_OWNER IMPACT_GEOM IMPACT_PLAYER IMPACT_SHOTS BOUNCE_GEOM BOUNCE_PLAYER BOUNCE_SHOTS DRILL_GEOM DRILL_PLAYER DRILL_SHOTS STICK_GEOM STICK_PLAYER COLLIDE_HITSCAN"
        setdesc (concatword $w flakexplcol $m) "determines the colour of the explosion of flak of this type" "colour"
        setdesc (concatword $w flakpartcol $m) "determines the colour of flak of this type" "colour"
        setdesc (concatword $w flakresidual $m) "determines the residual effects for flak of this type from each firing action (bitwise OR)" "burns bleeds shocks"
        setdesc (concatword $w partcol $m) "determines the colour of a projectile from this weapon" "colour"
        setdesc (concatword $w parttype $m) "determines the type of projectiles this weapon shoots" "value"
        setdesc (concatword $w residual $m) "determines the residual effects of a projectile from each firing action (bitwise OR)" "burns bleeds shocks"
        setdesc (concatword $w grab $m) "determines if the weapon is used for parkour grabs" "[can grab on walls] [can grab players]"
    ]
]
